(self.webpackChunkweb_plugin = self.webpackChunkweb_plugin || []).push([
    [96], {
        2167: (e, t) => {
            "use strict";

            function n(e, t) {
                return void 0 === t && (t = Object), t && "function" == typeof t.freeze ? t.freeze(e) : e
            }
            var s = n({
                    HTML: "text/html",
                    isHTML: function(e) {
                        return e === s.HTML
                    },
                    XML_APPLICATION: "application/xml",
                    XML_TEXT: "text/xml",
                    XML_XHTML_APPLICATION: "application/xhtml+xml",
                    XML_SVG_IMAGE: "image/svg+xml"
                }),
                r = n({
                    HTML: "http://www.w3.org/1999/xhtml",
                    isHTML: function(e) {
                        return e === r.HTML
                    },
                    SVG: "http://www.w3.org/2000/svg",
                    XML: "http://www.w3.org/XML/1998/namespace",
                    XMLNS: "http://www.w3.org/2000/xmlns/"
                });
            t.assign = function(e, t) {
                if (null === e || "object" != typeof e) throw new TypeError("target is not an object");
                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e
            }, t.freeze = n, t.MIME_TYPE = s, t.NAMESPACE = r
        },
        6129: (e, t, n) => {
            var s = n(2167),
                r = n(1146),
                i = n(1045),
                o = n(6925),
                a = r.DOMImplementation,
                l = s.NAMESPACE,
                c = o.ParseError,
                h = o.XMLReader;

            function u(e) {
                return e.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n")
            }

            function d(e) {
                this.options = e || {
                    locator: {}
                }
            }

            function p() {
                this.cdata = !1
            }

            function m(e, t) {
                t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber
            }

            function g(e) {
                if (e) return "\n@" + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]"
            }

            function f(e, t, n) {
                return "string" == typeof e ? e.substr(t, n) : e.length >= t + n || t ? new java.lang.String(e, t, n) + "" : e
            }

            function _(e, t) {
                e.currentElement ? e.currentElement.appendChild(t) : e.doc.appendChild(t)
            }
            d.prototype.parseFromString = function(e, t) {
                var n = this.options,
                    s = new h,
                    r = n.domBuilder || new p,
                    o = n.errorHandler,
                    a = n.locator,
                    c = n.xmlns || {},
                    d = /\/x?html?$/.test(t),
                    m = d ? i.HTML_ENTITIES : i.XML_ENTITIES;
                a && r.setDocumentLocator(a), s.errorHandler = function(e, t, n) {
                    if (!e) {
                        if (t instanceof p) return t;
                        e = t
                    }
                    var s = {},
                        r = e instanceof Function;

                    function i(t) {
                        var i = e[t];
                        !i && r && (i = 2 == e.length ? function(n) {
                            e(t, n)
                        } : e), s[t] = i && function(e) {
                            i("[xmldom " + t + "]\t" + e + g(n))
                        } || function() {}
                    }
                    return n = n || {}, i("warning"), i("error"), i("fatalError"), s
                }(o, r, a), s.domBuilder = n.domBuilder || r, d && (c[""] = l.HTML), c.xml = c.xml || l.XML;
                var f = n.normalizeLineEndings || u;
                return e && "string" == typeof e ? s.parse(f(e), c, m) : s.errorHandler.error("invalid doc source"), r.doc
            }, p.prototype = {
                startDocument: function() {
                    this.doc = (new a).createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId)
                },
                startElement: function(e, t, n, s) {
                    var r = this.doc,
                        i = r.createElementNS(e, n || t),
                        o = s.length;
                    _(this, i), this.currentElement = i, this.locator && m(this.locator, i);
                    for (var a = 0; a < o; a++) {
                        e = s.getURI(a);
                        var l = s.getValue(a),
                            c = (n = s.getQName(a), r.createAttributeNS(e, n));
                        this.locator && m(s.getLocator(a), c), c.value = c.nodeValue = l, i.setAttributeNode(c)
                    }
                },
                endElement: function(e, t, n) {
                    var s = this.currentElement;
                    s.tagName, this.currentElement = s.parentNode
                },
                startPrefixMapping: function(e, t) {},
                endPrefixMapping: function(e) {},
                processingInstruction: function(e, t) {
                    var n = this.doc.createProcessingInstruction(e, t);
                    this.locator && m(this.locator, n), _(this, n)
                },
                ignorableWhitespace: function(e, t, n) {},
                characters: function(e, t, n) {
                    if (e = f.apply(this, arguments)) {
                        if (this.cdata) var s = this.doc.createCDATASection(e);
                        else s = this.doc.createTextNode(e);
                        this.currentElement ? this.currentElement.appendChild(s) : /^\s*$/.test(e) && this.doc.appendChild(s), this.locator && m(this.locator, s)
                    }
                },
                skippedEntity: function(e) {},
                endDocument: function() {
                    this.doc.normalize()
                },
                setDocumentLocator: function(e) {
                    (this.locator = e) && (e.lineNumber = 0)
                },
                comment: function(e, t, n) {
                    e = f.apply(this, arguments);
                    var s = this.doc.createComment(e);
                    this.locator && m(this.locator, s), _(this, s)
                },
                startCDATA: function() {
                    this.cdata = !0
                },
                endCDATA: function() {
                    this.cdata = !1
                },
                startDTD: function(e, t, n) {
                    var s = this.doc.implementation;
                    if (s && s.createDocumentType) {
                        var r = s.createDocumentType(e, t, n);
                        this.locator && m(this.locator, r), _(this, r), this.doc.doctype = r
                    }
                },
                warning: function(e) {
                    console.warn("[xmldom warning]\t" + e, g(this.locator))
                },
                error: function(e) {
                    console.error("[xmldom error]\t" + e, g(this.locator))
                },
                fatalError: function(e) {
                    throw new c(e, this.locator)
                }
            }, "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, (function(e) {
                p.prototype[e] = function() {
                    return null
                }
            })), t.DOMParser = d
        },
        1146: (e, t, n) => {
            var s = n(2167).NAMESPACE;

            function r(e) {
                return "" !== e
            }

            function i(e, t) {
                return e.hasOwnProperty(t) || (e[t] = !0), e
            }

            function o(e) {
                if (!e) return [];
                var t = function(e) {
                    return e ? e.split(/[\t\n\f\r ]+/).filter(r) : []
                }(e);
                return Object.keys(t.reduce(i, {}))
            }

            function a(e, t) {
                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }

            function l(e, t) {
                var n = e.prototype;
                if (!(n instanceof t)) {
                    function s() {}
                    s.prototype = t.prototype, a(n, s = new s), e.prototype = n = s
                }
                n.constructor != e && ("function" != typeof e && console.error("unknown Class:" + e), n.constructor = e)
            }
            var c = {},
                h = c.ELEMENT_NODE = 1,
                u = c.ATTRIBUTE_NODE = 2,
                d = c.TEXT_NODE = 3,
                p = c.CDATA_SECTION_NODE = 4,
                m = c.ENTITY_REFERENCE_NODE = 5,
                g = c.ENTITY_NODE = 6,
                f = c.PROCESSING_INSTRUCTION_NODE = 7,
                _ = c.COMMENT_NODE = 8,
                b = c.DOCUMENT_NODE = 9,
                N = c.DOCUMENT_TYPE_NODE = 10,
                S = c.DOCUMENT_FRAGMENT_NODE = 11,
                w = c.NOTATION_NODE = 12,
                T = {},
                y = {},
                v = (T.INDEX_SIZE_ERR = (y[1] = "Index size error", 1), T.DOMSTRING_SIZE_ERR = (y[2] = "DOMString size error", 2), T.HIERARCHY_REQUEST_ERR = (y[3] = "Hierarchy request error", 3)),
                x = (T.WRONG_DOCUMENT_ERR = (y[4] = "Wrong document", 4), T.INVALID_CHARACTER_ERR = (y[5] = "Invalid character", 5), T.NO_DATA_ALLOWED_ERR = (y[6] = "No data allowed", 6), T.NO_MODIFICATION_ALLOWED_ERR = (y[7] = "No modification allowed", 7), T.NOT_FOUND_ERR = (y[8] = "Not found", 8)),
                E = (T.NOT_SUPPORTED_ERR = (y[9] = "Not supported", 9), T.INUSE_ATTRIBUTE_ERR = (y[10] = "Attribute in use", 10));

            function A(e, t) {
                if (t instanceof Error) var n = t;
                else n = this, Error.call(this, y[e]), this.message = y[e], Error.captureStackTrace && Error.captureStackTrace(this, A);
                return n.code = e, t && (this.message = this.message + ": " + t), n
            }

            function C() {}

            function I(e, t) {
                this._node = e, this._refresh = t, O(this)
            }

            function O(e) {
                var t = e._node._inc || e._node.ownerDocument._inc;
                if (e._inc != t) {
                    var n = e._refresh(e._node);
                    ce(e, "length", n.length), a(n, e), e._inc = t
                }
            }

            function D() {}

            function R(e, t) {
                for (var n = e.length; n--;)
                    if (e[n] === t) return n
            }

            function M(e, t, n, r) {
                if (r ? t[R(t, r)] = n : t[t.length++] = n, e) {
                    n.ownerElement = e;
                    var i = e.ownerDocument;
                    i && (r && P(i, e, r), function(e, t, n) {
                        e && e._inc++, n.namespaceURI === s.XMLNS && (t._nsMap[n.prefix ? n.localName : ""] = n.value)
                    }(i, e, n))
                }
            }

            function H(e, t, n) {
                var s = R(t, n);
                if (!(s >= 0)) throw A(x, new Error(e.tagName + "@" + n));
                for (var r = t.length - 1; s < r;) t[s] = t[++s];
                if (t.length = r, e) {
                    var i = e.ownerDocument;
                    i && (P(i, e, n), n.ownerElement = null)
                }
            }

            function L() {}

            function q() {}

            function k(e) {
                return ("<" == e ? "&lt;" : ">" == e && "&gt;") || "&" == e && "&amp;" || '"' == e && "&quot;" || "&#" + e.charCodeAt() + ";"
            }

            function F(e, t) {
                if (t(e)) return !0;
                if (e = e.firstChild)
                    do {
                        if (F(e, t)) return !0
                    } while (e = e.nextSibling)
            }

            function B() {}

            function P(e, t, n, r) {
                e && e._inc++, n.namespaceURI === s.XMLNS && delete t._nsMap[n.prefix ? n.localName : ""]
            }

            function U(e, t, n) {
                if (e && e._inc) {
                    e._inc++;
                    var s = t.childNodes;
                    if (n) s[s.length++] = n;
                    else {
                        for (var r = t.firstChild, i = 0; r;) s[i++] = r, r = r.nextSibling;
                        s.length = i, delete s[s.length]
                    }
                }
            }

            function j(e, t) {
                var n = t.previousSibling,
                    s = t.nextSibling;
                return n ? n.nextSibling = s : e.firstChild = s, s ? s.previousSibling = n : e.lastChild = n, t.parentNode = null, t.previousSibling = null, t.nextSibling = null, U(e.ownerDocument, e), t
            }

            function X(e, t, n) {
                var s = t.parentNode;
                if (s && s.removeChild(t), t.nodeType === S) {
                    var r = t.firstChild;
                    if (null == r) return t;
                    var i = t.lastChild
                } else r = i = t;
                var o = n ? n.previousSibling : e.lastChild;
                r.previousSibling = o, i.nextSibling = n, o ? o.nextSibling = r : e.firstChild = r, null == n ? e.lastChild = i : n.previousSibling = i;
                do {
                    r.parentNode = e
                } while (r !== i && (r = r.nextSibling));
                return U(e.ownerDocument || e, e), t.nodeType == S && (t.firstChild = t.lastChild = null), t
            }

            function $() {
                this._nsMap = {}
            }

            function z() {}

            function G() {}

            function J() {}

            function W() {}

            function V() {}

            function Y() {}

            function Q() {}

            function K() {}

            function Z() {}

            function ee() {}

            function te() {}

            function ne() {}

            function se(e, t) {
                var n = [],
                    s = 9 == this.nodeType && this.documentElement || this,
                    r = s.prefix,
                    i = s.namespaceURI;
                if (i && null == r && null == (r = s.lookupPrefix(i))) var o = [{
                    namespace: i,
                    prefix: null
                }];
                return oe(this, n, e, t, o), n.join("")
            }

            function re(e, t, n) {
                var r = e.prefix || "",
                    i = e.namespaceURI;
                if (!i) return !1;
                if ("xml" === r && i === s.XML || i === s.XMLNS) return !1;
                for (var o = n.length; o--;) {
                    var a = n[o];
                    if (a.prefix === r) return a.namespace !== i
                }
                return !0
            }

            function ie(e, t, n) {
                e.push(" ", t, '="', n.replace(/[<>&"\t\n\r]/g, k), '"')
            }

            function oe(e, t, n, r, i) {
                if (i || (i = []), r) {
                    if (!(e = r(e))) return;
                    if ("string" == typeof e) return void t.push(e)
                }
                switch (e.nodeType) {
                    case h:
                        var o = e.attributes,
                            a = o.length,
                            l = e.firstChild,
                            c = e.tagName,
                            g = c;
                        if (!(n = s.isHTML(e.namespaceURI) || n) && !e.prefix && e.namespaceURI) {
                            for (var w, T = 0; T < o.length; T++)
                                if ("xmlns" === o.item(T).name) {
                                    w = o.item(T).value;
                                    break
                                }
                            if (!w)
                                for (var y = i.length - 1; y >= 0; y--)
                                    if ("" === (v = i[y]).prefix && v.namespace === e.namespaceURI) {
                                        w = v.namespace;
                                        break
                                    }
                            if (w !== e.namespaceURI)
                                for (y = i.length - 1; y >= 0; y--) {
                                    var v;
                                    if ((v = i[y]).namespace === e.namespaceURI) {
                                        v.prefix && (g = v.prefix + ":" + c);
                                        break
                                    }
                                }
                        }
                        t.push("<", g);
                        for (var x = 0; x < a; x++) "xmlns" == (E = o.item(x)).prefix ? i.push({
                            prefix: E.localName,
                            namespace: E.value
                        }) : "xmlns" == E.nodeName && i.push({
                            prefix: "",
                            namespace: E.value
                        });
                        for (x = 0; x < a; x++) {
                            var E, A, C;
                            re(E = o.item(x), 0, i) && (ie(t, (A = E.prefix || "") ? "xmlns:" + A : "xmlns", C = E.namespaceURI), i.push({
                                prefix: A,
                                namespace: C
                            })), oe(E, t, n, r, i)
                        }
                        if (c === g && re(e, 0, i) && (ie(t, (A = e.prefix || "") ? "xmlns:" + A : "xmlns", C = e.namespaceURI), i.push({
                                prefix: A,
                                namespace: C
                            })), l || n && !/^(?:meta|link|img|br|hr|input)$/i.test(c)) {
                            if (t.push(">"), n && /^script$/i.test(c))
                                for (; l;) l.data ? t.push(l.data) : oe(l, t, n, r, i.slice()), l = l.nextSibling;
                            else
                                for (; l;) oe(l, t, n, r, i.slice()), l = l.nextSibling;
                            t.push("</", g, ">")
                        } else t.push("/>");
                        return;
                    case b:
                    case S:
                        for (l = e.firstChild; l;) oe(l, t, n, r, i.slice()), l = l.nextSibling;
                        return;
                    case u:
                        return ie(t, e.name, e.value);
                    case d:
                        return t.push(e.data.replace(/[<&>]/g, k));
                    case p:
                        return t.push("<![CDATA[", e.data, "]]>");
                    case _:
                        return t.push("\x3c!--", e.data, "--\x3e");
                    case N:
                        var I = e.publicId,
                            O = e.systemId;
                        if (t.push("<!DOCTYPE ", e.name), I) t.push(" PUBLIC ", I), O && "." != O && t.push(" ", O), t.push(">");
                        else if (O && "." != O) t.push(" SYSTEM ", O, ">");
                        else {
                            var D = e.internalSubset;
                            D && t.push(" [", D, "]"), t.push(">")
                        }
                        return;
                    case f:
                        return t.push("<?", e.target, " ", e.data, "?>");
                    case m:
                        return t.push("&", e.nodeName, ";");
                    default:
                        t.push("??", e.nodeName)
                }
            }

            function ae(e, t, n) {
                var s;
                switch (t.nodeType) {
                    case h:
                        (s = t.cloneNode(!1)).ownerDocument = e;
                    case S:
                        break;
                    case u:
                        n = !0
                }
                if (s || (s = t.cloneNode(!1)), s.ownerDocument = e, s.parentNode = null, n)
                    for (var r = t.firstChild; r;) s.appendChild(ae(e, r, n)), r = r.nextSibling;
                return s
            }

            function le(e, t, n) {
                var s = new t.constructor;
                for (var r in t)
                    if (Object.prototype.hasOwnProperty.call(t, r)) {
                        var i = t[r];
                        "object" != typeof i && i != s[r] && (s[r] = i)
                    }
                switch (t.childNodes && (s.childNodes = new C), s.ownerDocument = e, s.nodeType) {
                    case h:
                        var o = t.attributes,
                            a = s.attributes = new D,
                            l = o.length;
                        a._ownerElement = s;
                        for (var c = 0; c < l; c++) s.setAttributeNode(le(e, o.item(c), !0));
                        break;
                    case u:
                        n = !0
                }
                if (n)
                    for (var d = t.firstChild; d;) s.appendChild(le(e, d, n)), d = d.nextSibling;
                return s
            }

            function ce(e, t, n) {
                e[t] = n
            }
            T.INVALID_STATE_ERR = (y[11] = "Invalid state", 11), T.SYNTAX_ERR = (y[12] = "Syntax error", 12), T.INVALID_MODIFICATION_ERR = (y[13] = "Invalid modification", 13), T.NAMESPACE_ERR = (y[14] = "Invalid namespace", 14), T.INVALID_ACCESS_ERR = (y[15] = "Invalid access", 15), A.prototype = Error.prototype, a(T, A), C.prototype = {
                length: 0,
                item: function(e) {
                    return this[e] || null
                },
                toString: function(e, t) {
                    for (var n = [], s = 0; s < this.length; s++) oe(this[s], n, e, t);
                    return n.join("")
                }
            }, I.prototype.item = function(e) {
                return O(this), this[e]
            }, l(I, C), D.prototype = {
                length: 0,
                item: C.prototype.item,
                getNamedItem: function(e) {
                    for (var t = this.length; t--;) {
                        var n = this[t];
                        if (n.nodeName == e) return n
                    }
                },
                setNamedItem: function(e) {
                    var t = e.ownerElement;
                    if (t && t != this._ownerElement) throw new A(E);
                    var n = this.getNamedItem(e.nodeName);
                    return M(this._ownerElement, this, e, n), n
                },
                setNamedItemNS: function(e) {
                    var t, n = e.ownerElement;
                    if (n && n != this._ownerElement) throw new A(E);
                    return t = this.getNamedItemNS(e.namespaceURI, e.localName), M(this._ownerElement, this, e, t), t
                },
                removeNamedItem: function(e) {
                    var t = this.getNamedItem(e);
                    return H(this._ownerElement, this, t), t
                },
                removeNamedItemNS: function(e, t) {
                    var n = this.getNamedItemNS(e, t);
                    return H(this._ownerElement, this, n), n
                },
                getNamedItemNS: function(e, t) {
                    for (var n = this.length; n--;) {
                        var s = this[n];
                        if (s.localName == t && s.namespaceURI == e) return s
                    }
                    return null
                }
            }, L.prototype = {
                hasFeature: function(e, t) {
                    return !0
                },
                createDocument: function(e, t, n) {
                    var s = new B;
                    if (s.implementation = this, s.childNodes = new C, s.doctype = n || null, n && s.appendChild(n), t) {
                        var r = s.createElementNS(e, t);
                        s.appendChild(r)
                    }
                    return s
                },
                createDocumentType: function(e, t, n) {
                    var s = new Y;
                    return s.name = e, s.nodeName = e, s.publicId = t || "", s.systemId = n || "", s
                }
            }, q.prototype = {
                firstChild: null,
                lastChild: null,
                previousSibling: null,
                nextSibling: null,
                attributes: null,
                parentNode: null,
                childNodes: null,
                ownerDocument: null,
                nodeValue: null,
                namespaceURI: null,
                prefix: null,
                localName: null,
                insertBefore: function(e, t) {
                    return X(this, e, t)
                },
                replaceChild: function(e, t) {
                    this.insertBefore(e, t), t && this.removeChild(t)
                },
                removeChild: function(e) {
                    return j(this, e)
                },
                appendChild: function(e) {
                    return this.insertBefore(e, null)
                },
                hasChildNodes: function() {
                    return null != this.firstChild
                },
                cloneNode: function(e) {
                    return le(this.ownerDocument || this, this, e)
                },
                normalize: function() {
                    for (var e = this.firstChild; e;) {
                        var t = e.nextSibling;
                        t && t.nodeType == d && e.nodeType == d ? (this.removeChild(t), e.appendData(t.data)) : (e.normalize(), e = t)
                    }
                },
                isSupported: function(e, t) {
                    return this.ownerDocument.implementation.hasFeature(e, t)
                },
                hasAttributes: function() {
                    return this.attributes.length > 0
                },
                lookupPrefix: function(e) {
                    for (var t = this; t;) {
                        var n = t._nsMap;
                        if (n)
                            for (var s in n)
                                if (Object.prototype.hasOwnProperty.call(n, s) && n[s] === e) return s;
                        t = t.nodeType == u ? t.ownerDocument : t.parentNode
                    }
                    return null
                },
                lookupNamespaceURI: function(e) {
                    for (var t = this; t;) {
                        var n = t._nsMap;
                        if (n && Object.prototype.hasOwnProperty.call(n, e)) return n[e];
                        t = t.nodeType == u ? t.ownerDocument : t.parentNode
                    }
                    return null
                },
                isDefaultNamespace: function(e) {
                    return null == this.lookupPrefix(e)
                }
            }, a(c, q), a(c, q.prototype), B.prototype = {
                nodeName: "#document",
                nodeType: b,
                doctype: null,
                documentElement: null,
                _inc: 1,
                insertBefore: function(e, t) {
                    if (e.nodeType == S) {
                        for (var n = e.firstChild; n;) {
                            var s = n.nextSibling;
                            this.insertBefore(n, t), n = s
                        }
                        return e
                    }
                    return null == this.documentElement && e.nodeType == h && (this.documentElement = e), X(this, e, t), e.ownerDocument = this, e
                },
                removeChild: function(e) {
                    return this.documentElement == e && (this.documentElement = null), j(this, e)
                },
                importNode: function(e, t) {
                    return ae(this, e, t)
                },
                getElementById: function(e) {
                    var t = null;
                    return F(this.documentElement, (function(n) {
                        if (n.nodeType == h && n.getAttribute("id") == e) return t = n, !0
                    })), t
                },
                getElementsByClassName: function(e) {
                    var t = o(e);
                    return new I(this, (function(n) {
                        var s = [];
                        return t.length > 0 && F(n.documentElement, (function(r) {
                            if (r !== n && r.nodeType === h) {
                                var i = r.getAttribute("class");
                                if (i) {
                                    var a = e === i;
                                    if (!a) {
                                        var l = o(i);
                                        a = t.every((c = l, function(e) {
                                            return c && -1 !== c.indexOf(e)
                                        }))
                                    }
                                    a && s.push(r)
                                }
                            }
                            var c
                        })), s
                    }))
                },
                createElement: function(e) {
                    var t = new $;
                    return t.ownerDocument = this, t.nodeName = e, t.tagName = e, t.localName = e, t.childNodes = new C, (t.attributes = new D)._ownerElement = t, t
                },
                createDocumentFragment: function() {
                    var e = new ee;
                    return e.ownerDocument = this, e.childNodes = new C, e
                },
                createTextNode: function(e) {
                    var t = new J;
                    return t.ownerDocument = this, t.appendData(e), t
                },
                createComment: function(e) {
                    var t = new W;
                    return t.ownerDocument = this, t.appendData(e), t
                },
                createCDATASection: function(e) {
                    var t = new V;
                    return t.ownerDocument = this, t.appendData(e), t
                },
                createProcessingInstruction: function(e, t) {
                    var n = new te;
                    return n.ownerDocument = this, n.tagName = n.target = e, n.nodeValue = n.data = t, n
                },
                createAttribute: function(e) {
                    var t = new z;
                    return t.ownerDocument = this, t.name = e, t.nodeName = e, t.localName = e, t.specified = !0, t
                },
                createEntityReference: function(e) {
                    var t = new Z;
                    return t.ownerDocument = this, t.nodeName = e, t
                },
                createElementNS: function(e, t) {
                    var n = new $,
                        s = t.split(":"),
                        r = n.attributes = new D;
                    return n.childNodes = new C, n.ownerDocument = this, n.nodeName = t, n.tagName = t, n.namespaceURI = e, 2 == s.length ? (n.prefix = s[0], n.localName = s[1]) : n.localName = t, r._ownerElement = n, n
                },
                createAttributeNS: function(e, t) {
                    var n = new z,
                        s = t.split(":");
                    return n.ownerDocument = this, n.nodeName = t, n.name = t, n.namespaceURI = e, n.specified = !0, 2 == s.length ? (n.prefix = s[0], n.localName = s[1]) : n.localName = t, n
                }
            }, l(B, q), $.prototype = {
                nodeType: h,
                hasAttribute: function(e) {
                    return null != this.getAttributeNode(e)
                },
                getAttribute: function(e) {
                    var t = this.getAttributeNode(e);
                    return t && t.value || ""
                },
                getAttributeNode: function(e) {
                    return this.attributes.getNamedItem(e)
                },
                setAttribute: function(e, t) {
                    var n = this.ownerDocument.createAttribute(e);
                    n.value = n.nodeValue = "" + t, this.setAttributeNode(n)
                },
                removeAttribute: function(e) {
                    var t = this.getAttributeNode(e);
                    t && this.removeAttributeNode(t)
                },
                appendChild: function(e) {
                    return e.nodeType === S ? this.insertBefore(e, null) : function(e, t) {
                        return t.parentNode && t.parentNode.removeChild(t), t.parentNode = e, t.previousSibling = e.lastChild, t.nextSibling = null, t.previousSibling ? t.previousSibling.nextSibling = t : e.firstChild = t, e.lastChild = t, U(e.ownerDocument, e, t), t
                    }(this, e)
                },
                setAttributeNode: function(e) {
                    return this.attributes.setNamedItem(e)
                },
                setAttributeNodeNS: function(e) {
                    return this.attributes.setNamedItemNS(e)
                },
                removeAttributeNode: function(e) {
                    return this.attributes.removeNamedItem(e.nodeName)
                },
                removeAttributeNS: function(e, t) {
                    var n = this.getAttributeNodeNS(e, t);
                    n && this.removeAttributeNode(n)
                },
                hasAttributeNS: function(e, t) {
                    return null != this.getAttributeNodeNS(e, t)
                },
                getAttributeNS: function(e, t) {
                    var n = this.getAttributeNodeNS(e, t);
                    return n && n.value || ""
                },
                setAttributeNS: function(e, t, n) {
                    var s = this.ownerDocument.createAttributeNS(e, t);
                    s.value = s.nodeValue = "" + n, this.setAttributeNode(s)
                },
                getAttributeNodeNS: function(e, t) {
                    return this.attributes.getNamedItemNS(e, t)
                },
                getElementsByTagName: function(e) {
                    return new I(this, (function(t) {
                        var n = [];
                        return F(t, (function(s) {
                            s === t || s.nodeType != h || "*" !== e && s.tagName != e || n.push(s)
                        })), n
                    }))
                },
                getElementsByTagNameNS: function(e, t) {
                    return new I(this, (function(n) {
                        var s = [];
                        return F(n, (function(r) {
                            r === n || r.nodeType !== h || "*" !== e && r.namespaceURI !== e || "*" !== t && r.localName != t || s.push(r)
                        })), s
                    }))
                }
            }, B.prototype.getElementsByTagName = $.prototype.getElementsByTagName, B.prototype.getElementsByTagNameNS = $.prototype.getElementsByTagNameNS, l($, q), z.prototype.nodeType = u, l(z, q), G.prototype = {
                data: "",
                substringData: function(e, t) {
                    return this.data.substring(e, e + t)
                },
                appendData: function(e) {
                    e = this.data + e, this.nodeValue = this.data = e, this.length = e.length
                },
                insertData: function(e, t) {
                    this.replaceData(e, 0, t)
                },
                appendChild: function(e) {
                    throw new Error(y[v])
                },
                deleteData: function(e, t) {
                    this.replaceData(e, t, "")
                },
                replaceData: function(e, t, n) {
                    n = this.data.substring(0, e) + n + this.data.substring(e + t), this.nodeValue = this.data = n, this.length = n.length
                }
            }, l(G, q), J.prototype = {
                nodeName: "#text",
                nodeType: d,
                splitText: function(e) {
                    var t = this.data,
                        n = t.substring(e);
                    t = t.substring(0, e), this.data = this.nodeValue = t, this.length = t.length;
                    var s = this.ownerDocument.createTextNode(n);
                    return this.parentNode && this.parentNode.insertBefore(s, this.nextSibling), s
                }
            }, l(J, G), W.prototype = {
                nodeName: "#comment",
                nodeType: _
            }, l(W, G), V.prototype = {
                nodeName: "#cdata-section",
                nodeType: p
            }, l(V, G), Y.prototype.nodeType = N, l(Y, q), Q.prototype.nodeType = w, l(Q, q), K.prototype.nodeType = g, l(K, q), Z.prototype.nodeType = m, l(Z, q), ee.prototype.nodeName = "#document-fragment", ee.prototype.nodeType = S, l(ee, q), te.prototype.nodeType = f, l(te, q), ne.prototype.serializeToString = function(e, t, n) {
                return se.call(e, t, n)
            }, q.prototype.toString = se;
            try {
                if (Object.defineProperty) {
                    function he(e) {
                        switch (e.nodeType) {
                            case h:
                            case S:
                                var t = [];
                                for (e = e.firstChild; e;) 7 !== e.nodeType && 8 !== e.nodeType && t.push(he(e)), e = e.nextSibling;
                                return t.join("");
                            default:
                                return e.nodeValue
                        }
                    }
                    Object.defineProperty(I.prototype, "length", {
                        get: function() {
                            return O(this), this.$$length
                        }
                    }), Object.defineProperty(q.prototype, "textContent", {
                        get: function() {
                            return he(this)
                        },
                        set: function(e) {
                            switch (this.nodeType) {
                                case h:
                                case S:
                                    for (; this.firstChild;) this.removeChild(this.firstChild);
                                    (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
                                    break;
                                default:
                                    this.data = e, this.value = e, this.nodeValue = e
                            }
                        }
                    }), ce = function(e, t, n) {
                        e["$$" + t] = n
                    }
                }
            } catch (ue) {}
            t.DocumentType = Y, t.DOMException = A, t.DOMImplementation = L, t.Element = $, t.Node = q, t.NodeList = C, t.XMLSerializer = ne
        },
        1045: (e, t, n) => {
            var s = n(2167).freeze;
            t.XML_ENTITIES = s({
                amp: "&",
                apos: "'",
                gt: ">",
                lt: "<",
                quot: '"'
            }), t.HTML_ENTITIES = s({
                lt: "<",
                gt: ">",
                amp: "&",
                quot: '"',
                apos: "'",
                Agrave: "À",
                Aacute: "Á",
                Acirc: "Â",
                Atilde: "Ã",
                Auml: "Ä",
                Aring: "Å",
                AElig: "Æ",
                Ccedil: "Ç",
                Egrave: "È",
                Eacute: "É",
                Ecirc: "Ê",
                Euml: "Ë",
                Igrave: "Ì",
                Iacute: "Í",
                Icirc: "Î",
                Iuml: "Ï",
                ETH: "Ð",
                Ntilde: "Ñ",
                Ograve: "Ò",
                Oacute: "Ó",
                Ocirc: "Ô",
                Otilde: "Õ",
                Ouml: "Ö",
                Oslash: "Ø",
                Ugrave: "Ù",
                Uacute: "Ú",
                Ucirc: "Û",
                Uuml: "Ü",
                Yacute: "Ý",
                THORN: "Þ",
                szlig: "ß",
                agrave: "à",
                aacute: "á",
                acirc: "â",
                atilde: "ã",
                auml: "ä",
                aring: "å",
                aelig: "æ",
                ccedil: "ç",
                egrave: "è",
                eacute: "é",
                ecirc: "ê",
                euml: "ë",
                igrave: "ì",
                iacute: "í",
                icirc: "î",
                iuml: "ï",
                eth: "ð",
                ntilde: "ñ",
                ograve: "ò",
                oacute: "ó",
                ocirc: "ô",
                otilde: "õ",
                ouml: "ö",
                oslash: "ø",
                ugrave: "ù",
                uacute: "ú",
                ucirc: "û",
                uuml: "ü",
                yacute: "ý",
                thorn: "þ",
                yuml: "ÿ",
                nbsp: " ",
                iexcl: "¡",
                cent: "¢",
                pound: "£",
                curren: "¤",
                yen: "¥",
                brvbar: "¦",
                sect: "§",
                uml: "¨",
                copy: "©",
                ordf: "ª",
                laquo: "«",
                not: "¬",
                shy: "­­",
                reg: "®",
                macr: "¯",
                deg: "°",
                plusmn: "±",
                sup2: "²",
                sup3: "³",
                acute: "´",
                micro: "µ",
                para: "¶",
                middot: "·",
                cedil: "¸",
                sup1: "¹",
                ordm: "º",
                raquo: "»",
                frac14: "¼",
                frac12: "½",
                frac34: "¾",
                iquest: "¿",
                times: "×",
                divide: "÷",
                forall: "∀",
                part: "∂",
                exist: "∃",
                empty: "∅",
                nabla: "∇",
                isin: "∈",
                notin: "∉",
                ni: "∋",
                prod: "∏",
                sum: "∑",
                minus: "−",
                lowast: "∗",
                radic: "√",
                prop: "∝",
                infin: "∞",
                ang: "∠",
                and: "∧",
                or: "∨",
                cap: "∩",
                cup: "∪",
                int: "∫",
                there4: "∴",
                sim: "∼",
                cong: "≅",
                asymp: "≈",
                ne: "≠",
                equiv: "≡",
                le: "≤",
                ge: "≥",
                sub: "⊂",
                sup: "⊃",
                nsub: "⊄",
                sube: "⊆",
                supe: "⊇",
                oplus: "⊕",
                otimes: "⊗",
                perp: "⊥",
                sdot: "⋅",
                Alpha: "Α",
                Beta: "Β",
                Gamma: "Γ",
                Delta: "Δ",
                Epsilon: "Ε",
                Zeta: "Ζ",
                Eta: "Η",
                Theta: "Θ",
                Iota: "Ι",
                Kappa: "Κ",
                Lambda: "Λ",
                Mu: "Μ",
                Nu: "Ν",
                Xi: "Ξ",
                Omicron: "Ο",
                Pi: "Π",
                Rho: "Ρ",
                Sigma: "Σ",
                Tau: "Τ",
                Upsilon: "Υ",
                Phi: "Φ",
                Chi: "Χ",
                Psi: "Ψ",
                Omega: "Ω",
                alpha: "α",
                beta: "β",
                gamma: "γ",
                delta: "δ",
                epsilon: "ε",
                zeta: "ζ",
                eta: "η",
                theta: "θ",
                iota: "ι",
                kappa: "κ",
                lambda: "λ",
                mu: "μ",
                nu: "ν",
                xi: "ξ",
                omicron: "ο",
                pi: "π",
                rho: "ρ",
                sigmaf: "ς",
                sigma: "σ",
                tau: "τ",
                upsilon: "υ",
                phi: "φ",
                chi: "χ",
                psi: "ψ",
                omega: "ω",
                thetasym: "ϑ",
                upsih: "ϒ",
                piv: "ϖ",
                OElig: "Œ",
                oelig: "œ",
                Scaron: "Š",
                scaron: "š",
                Yuml: "Ÿ",
                fnof: "ƒ",
                circ: "ˆ",
                tilde: "˜",
                ensp: " ",
                emsp: " ",
                thinsp: " ",
                zwnj: "‌",
                zwj: "‍",
                lrm: "‎",
                rlm: "‏",
                ndash: "–",
                mdash: "—",
                lsquo: "‘",
                rsquo: "’",
                sbquo: "‚",
                ldquo: "“",
                rdquo: "”",
                bdquo: "„",
                dagger: "†",
                Dagger: "‡",
                bull: "•",
                hellip: "…",
                permil: "‰",
                prime: "′",
                Prime: "″",
                lsaquo: "‹",
                rsaquo: "›",
                oline: "‾",
                euro: "€",
                trade: "™",
                larr: "←",
                uarr: "↑",
                rarr: "→",
                darr: "↓",
                harr: "↔",
                crarr: "↵",
                lceil: "⌈",
                rceil: "⌉",
                lfloor: "⌊",
                rfloor: "⌋",
                loz: "◊",
                spades: "♠",
                clubs: "♣",
                hearts: "♥",
                diams: "♦"
            }), t.entityMap = t.HTML_ENTITIES
        },
        3969: (e, t, n) => {
            var s = n(1146);
            t.u = s.DOMImplementation, s.XMLSerializer, t.DOMParser = n(6129).DOMParser
        },
        6925: (e, t, n) => {
            var s = n(2167).NAMESPACE,
                r = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
                i = new RegExp("[\\-\\.0-9" + r.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),
                o = new RegExp("^" + r.source + i.source + "*(?::" + r.source + i.source + "*)?$");

            function a(e, t) {
                this.message = e, this.locator = t, Error.captureStackTrace && Error.captureStackTrace(this, a)
            }

            function l() {}

            function c(e, t) {
                return t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber, t
            }

            function h(e, t, n, r, i, o) {
                function a(e, t, s) {
                    n.attributeNames.hasOwnProperty(e) && o.fatalError("Attribute " + e + " redefined"), n.addValue(e, t.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, i), s)
                }
                for (var l, c = ++t, h = 0;;) {
                    var u = e.charAt(c);
                    switch (u) {
                        case "=":
                            if (1 === h) l = e.slice(t, c), h = 3;
                            else {
                                if (2 !== h) throw new Error("attribute equal must after attrName");
                                h = 3
                            }
                            break;
                        case "'":
                        case '"':
                            if (3 === h || 1 === h) {
                                if (1 === h && (o.warning('attribute value must after "="'), l = e.slice(t, c)), t = c + 1, !((c = e.indexOf(u, t)) > 0)) throw new Error("attribute value no end '" + u + "' match");
                                a(l, d = e.slice(t, c), t - 1), h = 5
                            } else {
                                if (4 != h) throw new Error('attribute value must after "="');
                                a(l, d = e.slice(t, c), t), o.warning('attribute "' + l + '" missed start quot(' + u + ")!!"), t = c + 1, h = 5
                            }
                            break;
                        case "/":
                            switch (h) {
                                case 0:
                                    n.setTagName(e.slice(t, c));
                                case 5:
                                case 6:
                                case 7:
                                    h = 7, n.closed = !0;
                                case 4:
                                case 1:
                                case 2:
                                    break;
                                default:
                                    throw new Error("attribute invalid close char('/')")
                            }
                            break;
                        case "":
                            return o.error("unexpected end of input"), 0 == h && n.setTagName(e.slice(t, c)), c;
                        case ">":
                            switch (h) {
                                case 0:
                                    n.setTagName(e.slice(t, c));
                                case 5:
                                case 6:
                                case 7:
                                    break;
                                case 4:
                                case 1:
                                    "/" === (d = e.slice(t, c)).slice(-1) && (n.closed = !0, d = d.slice(0, -1));
                                case 2:
                                    2 === h && (d = l), 4 == h ? (o.warning('attribute "' + d + '" missed quot(")!'), a(l, d, t)) : (s.isHTML(r[""]) && d.match(/^(?:disabled|checked|selected)$/i) || o.warning('attribute "' + d + '" missed value!! "' + d + '" instead!!'), a(d, d, t));
                                    break;
                                case 3:
                                    throw new Error("attribute value missed!!")
                            }
                            return c;
                        case "":
                            u = " ";
                        default:
                            if (u <= " ") switch (h) {
                                case 0:
                                    n.setTagName(e.slice(t, c)), h = 6;
                                    break;
                                case 1:
                                    l = e.slice(t, c), h = 2;
                                    break;
                                case 4:
                                    var d = e.slice(t, c);
                                    o.warning('attribute "' + d + '" missed quot(")!!'), a(l, d, t);
                                case 5:
                                    h = 6
                            } else switch (h) {
                                case 2:
                                    n.tagName, s.isHTML(r[""]) && l.match(/^(?:disabled|checked|selected)$/i) || o.warning('attribute "' + l + '" missed value!! "' + l + '" instead2!!'), a(l, l, t), t = c, h = 1;
                                    break;
                                case 5:
                                    o.warning('attribute space is required"' + l + '"!!');
                                case 6:
                                    h = 1, t = c;
                                    break;
                                case 3:
                                    h = 4, t = c;
                                    break;
                                case 7:
                                    throw new Error("elements closed character '/' and '>' must be connected to")
                            }
                    }
                    c++
                }
            }

            function u(e, t, n) {
                for (var r = e.tagName, i = null, o = e.length; o--;) {
                    var a = e[o],
                        l = a.qName,
                        c = a.value;
                    if ((p = l.indexOf(":")) > 0) var h = a.prefix = l.slice(0, p),
                        u = l.slice(p + 1),
                        d = "xmlns" === h && u;
                    else u = l, h = null, d = "xmlns" === l && "";
                    a.localName = u, !1 !== d && (null == i && (i = {}, m(n, n = {})), n[d] = i[d] = c, a.uri = s.XMLNS, t.startPrefixMapping(d, c))
                }
                for (o = e.length; o--;)(h = (a = e[o]).prefix) && ("xml" === h && (a.uri = s.XML), "xmlns" !== h && (a.uri = n[h || ""]));
                var p;
                (p = r.indexOf(":")) > 0 ? (h = e.prefix = r.slice(0, p), u = e.localName = r.slice(p + 1)) : (h = null, u = e.localName = r);
                var g = e.uri = n[h || ""];
                if (t.startElement(g, u, r, e), !e.closed) return e.currentNSMap = n, e.localNSMap = i, !0;
                if (t.endElement(g, u, r), i)
                    for (h in i) Object.prototype.hasOwnProperty.call(i, h) && t.endPrefixMapping(h)
            }

            function d(e, t, n, s, r) {
                if (/^(?:script|textarea)$/i.test(n)) {
                    var i = e.indexOf("</" + n + ">", t),
                        o = e.substring(t + 1, i);
                    if (/[&<]/.test(o)) return /^script$/i.test(n) ? (r.characters(o, 0, o.length), i) : (o = o.replace(/&#?\w+;/g, s), r.characters(o, 0, o.length), i)
                }
                return t + 1
            }

            function p(e, t, n, s) {
                var r = s[n];
                return null == r && ((r = e.lastIndexOf("</" + n + ">")) < t && (r = e.lastIndexOf("</" + n)), s[n] = r), r < t
            }

            function m(e, t) {
                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }

            function g(e, t, n, s) {
                if ("-" === e.charAt(t + 2)) return "-" === e.charAt(t + 3) ? (r = e.indexOf("--\x3e", t + 4)) > t ? (n.comment(e, t + 4, r - t - 4), r + 3) : (s.error("Unclosed comment"), -1) : -1;
                if ("CDATA[" == e.substr(t + 3, 6)) {
                    var r = e.indexOf("]]>", t + 9);
                    return n.startCDATA(), n.characters(e, t + 9, r - t - 9), n.endCDATA(), r + 3
                }
                var i = function(e, t) {
                        var n, s = [],
                            r = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                        for (r.lastIndex = t, r.exec(e); n = r.exec(e);)
                            if (s.push(n), n[1]) return s
                    }(e, t),
                    o = i.length;
                if (o > 1 && /!doctype/i.test(i[0][0])) {
                    var a = i[1][0],
                        l = !1,
                        c = !1;
                    o > 3 && (/^public$/i.test(i[2][0]) ? (l = i[3][0], c = o > 4 && i[4][0]) : /^system$/i.test(i[2][0]) && (c = i[3][0]));
                    var h = i[o - 1];
                    return n.startDTD(a, l, c), n.endDTD(), h.index + h[0].length
                }
                return -1
            }

            function f(e, t, n) {
                var s = e.indexOf("?>", t);
                if (s) {
                    var r = e.substring(t, s).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                    return r ? (r[0].length, n.processingInstruction(r[1], r[2]), s + 2) : -1
                }
                return -1
            }

            function _() {
                this.attributeNames = {}
            }
            a.prototype = new Error, a.prototype.name = a.name, l.prototype = {
                parse: function(e, t, n) {
                    var r = this.domBuilder;
                    r.startDocument(), m(t, t = {}),
                        function(e, t, n, r, i) {
                            function o(e) {
                                var t = e.slice(1, -1);
                                return Object.hasOwnProperty.call(n, t) ? n[t] : "#" === t.charAt(0) ? function(e) {
                                    if (e > 65535) {
                                        var t = 55296 + ((e -= 65536) >> 10),
                                            n = 56320 + (1023 & e);
                                        return String.fromCharCode(t, n)
                                    }
                                    return String.fromCharCode(e)
                                }(parseInt(t.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + e), e)
                            }

                            function l(t) {
                                if (t > v) {
                                    var n = e.substring(v, t).replace(/&#?\w+;/g, o);
                                    w && m(v), r.characters(n, 0, t - v), v = t
                                }
                            }

                            function m(t, n) {
                                for (; t >= N && (n = S.exec(e));) b = n.index, N = b + n[0].length, w.lineNumber++;
                                w.columnNumber = t - b + 1
                            }
                            for (var b = 0, N = 0, S = /.*(?:\r\n?|\n)|.*$/g, w = r.locator, T = [{
                                    currentNSMap: t
                                }], y = {}, v = 0;;) {
                                try {
                                    var x = e.indexOf("<", v);
                                    if (x < 0) {
                                        if (!e.substr(v).match(/^\s*$/)) {
                                            var E = r.doc,
                                                A = E.createTextNode(e.substr(v));
                                            E.appendChild(A), r.currentElement = A
                                        }
                                        return
                                    }
                                    switch (x > v && l(x), e.charAt(x + 1)) {
                                        case "/":
                                            var C = e.indexOf(">", x + 3),
                                                I = e.substring(x + 2, C).replace(/[ \t\n\r]+$/g, ""),
                                                O = T.pop();
                                            C < 0 ? (I = e.substring(x + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + I + " is not complete:" + O.tagName), C = x + 1 + I.length) : I.match(/\s</) && (I = I.replace(/[\s<].*/, ""), i.error("end tag name: " + I + " maybe not complete"), C = x + 1 + I.length);
                                            var D = O.localNSMap,
                                                R = O.tagName == I;
                                            if (R || O.tagName && O.tagName.toLowerCase() == I.toLowerCase()) {
                                                if (r.endElement(O.uri, O.localName, I), D)
                                                    for (var M in D) Object.prototype.hasOwnProperty.call(D, M) && r.endPrefixMapping(M);
                                                R || i.fatalError("end tag name: " + I + " is not match the current start tagName:" + O.tagName)
                                            } else T.push(O);
                                            C++;
                                            break;
                                        case "?":
                                            w && m(x), C = f(e, x, r);
                                            break;
                                        case "!":
                                            w && m(x), C = g(e, x, r, i);
                                            break;
                                        default:
                                            w && m(x);
                                            var H = new _,
                                                L = T[T.length - 1].currentNSMap,
                                                q = (C = h(e, x, H, L, o, i), H.length);
                                            if (!H.closed && p(e, C, H.tagName, y) && (H.closed = !0, n.nbsp || i.warning("unclosed xml attribute")), w && q) {
                                                for (var k = c(w, {}), F = 0; F < q; F++) {
                                                    var B = H[F];
                                                    m(B.offset), B.locator = c(w, {})
                                                }
                                                r.locator = k, u(H, r, L) && T.push(H), r.locator = w
                                            } else u(H, r, L) && T.push(H);
                                            s.isHTML(H.uri) && !H.closed ? C = d(e, C, H.tagName, o, r) : C++
                                    }
                                } catch (e) {
                                    if (e instanceof a) throw e;
                                    i.error("element parse error: " + e), C = -1
                                }
                                C > v ? v = C : l(Math.max(x, v) + 1)
                            }
                        }(e, t, n, r, this.errorHandler), r.endDocument()
                }
            }, _.prototype = {
                setTagName: function(e) {
                    if (!o.test(e)) throw new Error("invalid tagName:" + e);
                    this.tagName = e
                },
                addValue: function(e, t, n) {
                    if (!o.test(e)) throw new Error("invalid attribute:" + e);
                    this.attributeNames[e] = this.length, this[this.length++] = {
                        qName: e,
                        value: t,
                        offset: n
                    }
                },
                length: 0,
                getLocalName: function(e) {
                    return this[e].localName
                },
                getLocator: function(e) {
                    return this[e].locator
                },
                getQName: function(e) {
                    return this[e].qName
                },
                getURI: function(e) {
                    return this[e].uri
                },
                getValue: function(e) {
                    return this[e].value
                }
            }, t.XMLReader = l, t.ParseError = a
        },
        4482: function(e, t, n) {
            ! function(e) {
                "use strict";
                var t = void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
                const s = function() {
                    let e = t.WebSocket;
                    if (void 0 === e) try {
                        e = n(7026)
                    } catch (e) {
                        throw new Error('You must install the "ws" package to use Strophe in nodejs.')
                    }
                    return e
                }();
                const r = function() {
                    let e = t.DOMParser;
                    if (void 0 === e) try {
                        e = n(3969).DOMParser
                    } catch (e) {
                        throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.')
                    }
                    return e
                }();

                function i() {
                    if ("undefined" == typeof document) try {
                        return (new(0, n(3969).u)).createDocument("jabber:client", "strophe", null)
                    } catch (e) {
                        throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.')
                    }
                    if (void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                        const e = function() {
                            const e = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];
                            for (let t = 0; t < e.length; t++) try {
                                return new ActiveXObject(e[t])
                            } catch (e) {}
                        }();
                        return e.appendChild(e.createElement("strophe")), e
                    }
                    return document.implementation.createDocument("jabber:client", "strophe", null)
                }
                class o {
                    constructor(e, t, n) {
                        this.mechname = e, this.isClientFirst = t, this.priority = n
                    }
                    test() {
                        return !0
                    }
                    onStart(e) {
                        this._connection = e
                    }
                    onChallenge(e, t) {
                        throw new Error("You should implement challenge handling!")
                    }
                    clientChallenge(e) {
                        if (!this.isClientFirst) throw new Error("clientChallenge should not be called if isClientFirst is false!");
                        return this.onChallenge(e)
                    }
                    onFailure() {
                        this._connection = null
                    }
                    onSuccess() {
                        this._connection = null
                    }
                }
                const a = {
                    utf16to8(e) {
                        let t = "";
                        const n = e.length;
                        for (let s = 0; s < n; s++) {
                            const n = e.charCodeAt(s);
                            n >= 0 && n <= 127 ? t += e.charAt(s) : n > 2047 ? (t += String.fromCharCode(224 | n >> 12 & 15), t += String.fromCharCode(128 | n >> 6 & 63), t += String.fromCharCode(128 | n >> 0 & 63)) : (t += String.fromCharCode(192 | n >> 6 & 31), t += String.fromCharCode(128 | n >> 0 & 63))
                        }
                        return t
                    },
                    xorArrayBuffers(e, t) {
                        const n = new Uint8Array(e),
                            s = new Uint8Array(t),
                            r = new Uint8Array(e.byteLength);
                        for (let t = 0; t < e.byteLength; t++) r[t] = n[t] ^ s[t];
                        return r.buffer
                    },
                    arrayBufToBase64(e) {
                        let t = "";
                        const n = new Uint8Array(e),
                            s = n.byteLength;
                        for (let e = 0; e < s; e++) t += String.fromCharCode(n[e]);
                        return window.btoa(t)
                    },
                    base64ToArrayBuf(e) {
                        var t;
                        return null === (t = Uint8Array.from(atob(e), (e => e.charCodeAt(0)))) || void 0 === t ? void 0 : t.buffer
                    },
                    stringToArrayBuf: e => new TextEncoder("utf-8").encode(e).buffer,
                    addCookies(e) {
                        e = e || {};
                        for (const t in e)
                            if (Object.prototype.hasOwnProperty.call(e, t)) {
                                let n = "",
                                    s = "",
                                    r = "";
                                const i = e[t],
                                    o = "object" == typeof i,
                                    a = escape(unescape(o ? i.value : i));
                                o && (n = i.expires ? ";expires=" + i.expires : "", s = i.domain ? ";domain=" + i.domain : "", r = i.path ? ";path=" + i.path : ""), document.cookie = t + "=" + a + n + s + r
                            }
                    }
                };
                const l = {
                    async scramResponse(e, t, n, s) {
                        var r, i, o;
                        const l = e._sasl_data.cnonce,
                            c = function(e) {
                                let t, n, s;
                                const r = /([a-z]+)=([^,]+)(,|$)/;
                                for (; e.match(r);) {
                                    const i = e.match(r);
                                    switch (e = e.replace(i[0], ""), i[1]) {
                                        case "r":
                                            t = i[2];
                                            break;
                                        case "s":
                                            n = a.base64ToArrayBuf(i[2]);
                                            break;
                                        case "i":
                                            s = parseInt(i[2], 10);
                                            break;
                                        default:
                                            return
                                    }
                                }
                                if (isNaN(s) || s < 4096) b.warn("Failing SCRAM authentication because server supplied iteration count < 4096.");
                                else {
                                    if (n) return {
                                        nonce: t,
                                        salt: n,
                                        iter: s
                                    };
                                    b.warn("Failing SCRAM authentication because server supplied incorrect salt.")
                                }
                            }(t);
                        if (!c && (null == c ? void 0 : c.nonce.slice(0, l.length)) !== l) return b.warn("Failing SCRAM authentication because server supplied incorrect nonce."), e._sasl_data = {}, e._sasl_failure_cb();
                        let h, u;
                        if ((null === (r = e.pass) || void 0 === r ? void 0 : r.name) === n && (null === (i = e.pass) || void 0 === i ? void 0 : i.salt) === a.arrayBufToBase64(c.salt) && (null === (o = e.pass) || void 0 === o ? void 0 : o.iter) === c.iter) h = a.base64ToArrayBuf(e.pass.ck), u = a.base64ToArrayBuf(e.pass.sk);
                        else {
                            if (!("string" == typeof e.pass || e.pass instanceof String)) return e._sasl_failure_cb(); {
                                const t = await async function(e, t, n, s, r) {
                                    const i = await window.crypto.subtle.deriveBits({
                                            name: "PBKDF2",
                                            salt: t,
                                            iterations: n,
                                            hash: {
                                                name: s
                                            }
                                        }, await window.crypto.subtle.importKey("raw", a.stringToArrayBuf(e), "PBKDF2", !1, ["deriveBits"]), r),
                                        o = await window.crypto.subtle.importKey("raw", i, {
                                            name: "HMAC",
                                            hash: s
                                        }, !1, ["sign"]);
                                    return {
                                        ck: await window.crypto.subtle.sign("HMAC", o, a.stringToArrayBuf("Client Key")),
                                        sk: await window.crypto.subtle.sign("HMAC", o, a.stringToArrayBuf("Server Key"))
                                    }
                                }(e.pass, c.salt, c.iter, n, s);
                                h = t.ck, u = t.sk
                            }
                        }
                        const d = e._sasl_data["client-first-message-bare"],
                            p = t,
                            m = `c=biws,r=${c.nonce}`,
                            g = `${d},${p},${m}`,
                            f = await async function(e, t, n) {
                                const s = await window.crypto.subtle.importKey("raw", await window.crypto.subtle.digest(n, t), {
                                        name: "HMAC",
                                        hash: n
                                    }, !1, ["sign"]),
                                    r = await window.crypto.subtle.sign("HMAC", s, a.stringToArrayBuf(e));
                                return a.xorArrayBuffers(t, r)
                            }(g, h, n),
                            _ = await async function(e, t, n) {
                                const s = await window.crypto.subtle.importKey("raw", t, {
                                    name: "HMAC",
                                    hash: n
                                }, !1, ["sign"]);
                                return window.crypto.subtle.sign("HMAC", s, a.stringToArrayBuf(e))
                            }(g, u, n);
                        return e._sasl_data["server-signature"] = a.arrayBufToBase64(_), e._sasl_data.keys = {
                            name: n,
                            iter: c.iter,
                            salt: a.arrayBufToBase64(c.salt),
                            ck: a.arrayBufToBase64(h),
                            sk: a.arrayBufToBase64(u)
                        }, `${m},p=${a.arrayBufToBase64(f)}`
                    },
                    clientChallenge(e, t) {
                        const n = t || function() {
                                const e = new Uint8Array(16);
                                return a.arrayBufToBase64(crypto.getRandomValues(e).buffer)
                            }(),
                            s = `n=${e.authcid},r=${n}`;
                        return e._sasl_data.cnonce = n, e._sasl_data["client-first-message-bare"] = s, `n,,${s}`
                    }
                };
                const c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

                function h(e) {
                    const t = c.indexOf(e);
                    return t < 0 ? void 0 : t
                }
                const u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

                function d(e) {
                    if (e >= 0 && e < 64) return u[e]
                }
                var p = {
                    atob: function(e) {
                        if (0 === arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                        if ((e = (e = `${e}`).replace(/[ \t\n\f\r]/g, "")).length % 4 == 0 && (e = e.replace(/==?$/, "")), e.length % 4 == 1 || /[^+/0-9A-Za-z]/.test(e)) return null;
                        let t = "",
                            n = 0,
                            s = 0;
                        for (let r = 0; r < e.length; r++) n <<= 6, n |= h(e[r]), s += 6, 24 === s && (t += String.fromCharCode((16711680 & n) >> 16), t += String.fromCharCode((65280 & n) >> 8), t += String.fromCharCode(255 & n), n = s = 0);
                        return 12 === s ? (n >>= 4, t += String.fromCharCode(n)) : 18 === s && (n >>= 2, t += String.fromCharCode((65280 & n) >> 8), t += String.fromCharCode(255 & n)), t
                    },
                    btoa: function(e) {
                        if (0 === arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                        let t;
                        for (e = `${e}`, t = 0; t < e.length; t++)
                            if (e.charCodeAt(t) > 255) return null;
                        let n = "";
                        for (t = 0; t < e.length; t += 3) {
                            const s = [void 0, void 0, void 0, void 0];
                            s[0] = e.charCodeAt(t) >> 2, s[1] = (3 & e.charCodeAt(t)) << 4, e.length > t + 1 && (s[1] |= e.charCodeAt(t + 1) >> 4, s[2] = (15 & e.charCodeAt(t + 1)) << 2), e.length > t + 2 && (s[2] |= e.charCodeAt(t + 2) >> 6, s[3] = 63 & e.charCodeAt(t + 2));
                            for (let e = 0; e < s.length; e++) void 0 === s[e] ? n += "=" : n += d(s[e])
                        }
                        return n
                    }
                };

                function m(e, t) {
                    return new b.Builder(e, t)
                }

                function g(e) {
                    return new b.Builder("message", e)
                }

                function f(e) {
                    return new b.Builder("iq", e)
                }

                function _(e) {
                    return new b.Builder("presence", e)
                }
                const b = {
                    VERSION: "1.6.0",
                    NS: {
                        HTTPBIND: "http://jabber.org/protocol/httpbind",
                        BOSH: "urn:xmpp:xbosh",
                        CLIENT: "jabber:client",
                        AUTH: "jabber:iq:auth",
                        ROSTER: "jabber:iq:roster",
                        PROFILE: "jabber:iq:profile",
                        DISCO_INFO: "http://jabber.org/protocol/disco#info",
                        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                        MUC: "http://jabber.org/protocol/muc",
                        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                        STREAM: "http://etherx.jabber.org/streams",
                        FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                        VERSION: "jabber:iq:version",
                        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                        XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                        XHTML: "http://www.w3.org/1999/xhtml"
                    },
                    XHTML: {
                        tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                        attributes: {
                            a: ["href"],
                            blockquote: ["style"],
                            br: [],
                            cite: ["style"],
                            em: [],
                            img: ["src", "alt", "style", "height", "width"],
                            li: ["style"],
                            ol: ["style"],
                            p: ["style"],
                            span: ["style"],
                            strong: [],
                            ul: ["style"],
                            body: []
                        },
                        css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                        validTag(e) {
                            for (let t = 0; t < b.XHTML.tags.length; t++)
                                if (e === b.XHTML.tags[t]) return !0;
                            return !1
                        },
                        validAttribute(e, t) {
                            if (void 0 !== b.XHTML.attributes[e] && b.XHTML.attributes[e].length > 0)
                                for (let n = 0; n < b.XHTML.attributes[e].length; n++)
                                    if (t === b.XHTML.attributes[e][n]) return !0;
                            return !1
                        },
                        validCSS(e) {
                            for (let t = 0; t < b.XHTML.css.length; t++)
                                if (e === b.XHTML.css[t]) return !0;
                            return !1
                        }
                    },
                    Status: {
                        ERROR: 0,
                        CONNECTING: 1,
                        CONNFAIL: 2,
                        AUTHENTICATING: 3,
                        AUTHFAIL: 4,
                        CONNECTED: 5,
                        DISCONNECTED: 6,
                        DISCONNECTING: 7,
                        ATTACHED: 8,
                        REDIRECT: 9,
                        CONNTIMEOUT: 10,
                        BINDREQUIRED: 11,
                        ATTACHFAIL: 12
                    },
                    ErrorCondition: {
                        BAD_FORMAT: "bad-format",
                        CONFLICT: "conflict",
                        MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                        NO_AUTH_MECH: "no-auth-mech",
                        UNKNOWN_REASON: "unknown"
                    },
                    LogLevel: {
                        DEBUG: 0,
                        INFO: 1,
                        WARN: 2,
                        ERROR: 3,
                        FATAL: 4
                    },
                    ElementType: {
                        NORMAL: 1,
                        TEXT: 3,
                        CDATA: 4,
                        FRAGMENT: 11
                    },
                    TIMEOUT: 1.1,
                    SECONDARY_TIMEOUT: .1,
                    addNamespace(e, t) {
                        b.NS[e] = t
                    },
                    forEachChild(e, t, n) {
                        for (let s = 0; s < e.childNodes.length; s++) {
                            const r = e.childNodes[s];
                            r.nodeType !== b.ElementType.NORMAL || t && !this.isTagEqual(r, t) || n(r)
                        }
                    },
                    isTagEqual: (e, t) => e.tagName === t,
                    _xmlGenerator: null,
                    xmlGenerator: () => (b._xmlGenerator || (b._xmlGenerator = i()), b._xmlGenerator),
                    xmlElement(e) {
                        if (!e) return null;
                        const t = b.xmlGenerator().createElement(e);
                        for (let e = 1; e < arguments.length; e++) {
                            const n = arguments[e];
                            if (n)
                                if ("string" == typeof n || "number" == typeof n) t.appendChild(b.xmlTextNode(n));
                                else if ("object" == typeof n && "function" == typeof n.sort)
                                for (let e = 0; e < n.length; e++) {
                                    const s = n[e];
                                    "object" == typeof s && "function" == typeof s.sort && void 0 !== s[1] && null !== s[1] && t.setAttribute(s[0], s[1])
                                } else if ("object" == typeof n)
                                    for (const e in n) Object.prototype.hasOwnProperty.call(n, e) && void 0 !== n[e] && null !== n[e] && t.setAttribute(e, n[e])
                        }
                        return t
                    },
                    xmlescape: e => (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;"),
                    xmlunescape: e => (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"'),
                    xmlTextNode: e => b.xmlGenerator().createTextNode(e),
                    xmlHtmlNode(e) {
                        let t;
                        return r ? t = (new r).parseFromString(e, "text/xml") : (t = new ActiveXObject("Microsoft.XMLDOM"), t.async = "false", t.loadXML(e)), t
                    },
                    getText(e) {
                        if (!e) return null;
                        let t = "";
                        0 === e.childNodes.length && e.nodeType === b.ElementType.TEXT && (t += e.nodeValue);
                        for (let n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === b.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
                        return b.xmlescape(t)
                    },
                    copyElement(e) {
                        let t;
                        if (e.nodeType === b.ElementType.NORMAL) {
                            t = b.xmlElement(e.tagName);
                            for (let n = 0; n < e.attributes.length; n++) t.setAttribute(e.attributes[n].nodeName, e.attributes[n].value);
                            for (let n = 0; n < e.childNodes.length; n++) t.appendChild(b.copyElement(e.childNodes[n]))
                        } else e.nodeType === b.ElementType.TEXT && (t = b.xmlGenerator().createTextNode(e.nodeValue));
                        return t
                    },
                    createHtml(e) {
                        let t;
                        if (e.nodeType === b.ElementType.NORMAL) {
                            const n = e.nodeName.toLowerCase();
                            if (b.XHTML.validTag(n)) try {
                                t = b.xmlElement(n);
                                for (let s = 0; s < b.XHTML.attributes[n].length; s++) {
                                    const r = b.XHTML.attributes[n][s];
                                    let i = e.getAttribute(r);
                                    if (null != i && "" !== i && !1 !== i && 0 !== i)
                                        if ("style" === r && "object" == typeof i && void 0 !== i.cssText && (i = i.cssText), "style" === r) {
                                            const e = [],
                                                n = i.split(";");
                                            for (let t = 0; t < n.length; t++) {
                                                const s = n[t].split(":"),
                                                    r = s[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                if (b.XHTML.validCSS(r)) {
                                                    const t = s[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                    e.push(r + ": " + t)
                                                }
                                            }
                                            e.length > 0 && (i = e.join("; "), t.setAttribute(r, i))
                                        } else t.setAttribute(r, i)
                                }
                                for (let n = 0; n < e.childNodes.length; n++) t.appendChild(b.createHtml(e.childNodes[n]))
                            } catch (e) {
                                t = b.xmlTextNode("")
                            } else {
                                t = b.xmlGenerator().createDocumentFragment();
                                for (let n = 0; n < e.childNodes.length; n++) t.appendChild(b.createHtml(e.childNodes[n]))
                            }
                        } else if (e.nodeType === b.ElementType.FRAGMENT) {
                            t = b.xmlGenerator().createDocumentFragment();
                            for (let n = 0; n < e.childNodes.length; n++) t.appendChild(b.createHtml(e.childNodes[n]))
                        } else e.nodeType === b.ElementType.TEXT && (t = b.xmlTextNode(e.nodeValue));
                        return t
                    },
                    escapeNode: e => "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40"),
                    unescapeNode: e => "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\"),
                    getNodeFromJid: e => e.indexOf("@") < 0 ? null : e.split("@")[0],
                    getDomainFromJid(e) {
                        const t = b.getBareJidFromJid(e);
                        if (t.indexOf("@") < 0) return t; {
                            const e = t.split("@");
                            return e.splice(0, 1), e.join("@")
                        }
                    },
                    getResourceFromJid(e) {
                        if (!e) return null;
                        const t = e.split("/");
                        return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                    },
                    getBareJidFromJid: e => e ? e.split("/")[0] : null,
                    _handleError(e) {
                        void 0 !== e.stack && b.fatal(e.stack), e.sourceURL ? b.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? b.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : b.fatal("error: " + e.message)
                    },
                    log(e, t) {
                        var n;
                        e === this.LogLevel.FATAL && (null === (n = console) || void 0 === n || n.error(t))
                    },
                    debug(e) {
                        this.log(this.LogLevel.DEBUG, e)
                    },
                    info(e) {
                        this.log(this.LogLevel.INFO, e)
                    },
                    warn(e) {
                        this.log(this.LogLevel.WARN, e)
                    },
                    error(e) {
                        this.log(this.LogLevel.ERROR, e)
                    },
                    fatal(e) {
                        this.log(this.LogLevel.FATAL, e)
                    },
                    serialize(e) {
                        if (!e) return null;
                        "function" == typeof e.tree && (e = e.tree());
                        const t = [...Array(e.attributes.length).keys()].map((t => e.attributes[t].nodeName));
                        t.sort();
                        let n = t.reduce(((t, n) => `${t} ${n}="${b.xmlescape(e.attributes.getNamedItem(n).value)}"`), `<${e.nodeName}`);
                        if (e.childNodes.length > 0) {
                            n += ">";
                            for (let t = 0; t < e.childNodes.length; t++) {
                                const s = e.childNodes[t];
                                switch (s.nodeType) {
                                    case b.ElementType.NORMAL:
                                        n += b.serialize(s);
                                        break;
                                    case b.ElementType.TEXT:
                                        n += b.xmlescape(s.nodeValue);
                                        break;
                                    case b.ElementType.CDATA:
                                        n += "<![CDATA[" + s.nodeValue + "]]>"
                                }
                            }
                            n += "</" + e.nodeName + ">"
                        } else n += "/>";
                        return n
                    },
                    _requestId: 0,
                    _connectionPlugins: {},
                    addConnectionPlugin(e, t) {
                        b._connectionPlugins[e] = t
                    },
                    Builder: class {
                        constructor(e, t) {
                            "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = b.NS.CLIENT : t || (t = {
                                xmlns: b.NS.CLIENT
                            })), this.nodeTree = b.xmlElement(e, t), this.node = this.nodeTree
                        }
                        tree() {
                            return this.nodeTree
                        }
                        toString() {
                            return b.serialize(this.nodeTree)
                        }
                        up() {
                            return this.node = this.node.parentNode, this
                        }
                        root() {
                            return this.node = this.nodeTree, this
                        }
                        attrs(e) {
                            for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                            return this
                        }
                        c(e, t, n) {
                            const s = b.xmlElement(e, t, n);
                            return this.node.appendChild(s), "string" != typeof n && "number" != typeof n && (this.node = s), this
                        }
                        cnode(e) {
                            let t;
                            const n = b.xmlGenerator();
                            try {
                                t = void 0 !== n.importNode
                            } catch (e) {
                                t = !1
                            }
                            const s = t ? n.importNode(e, !0) : b.copyElement(e);
                            return this.node.appendChild(s), this.node = s, this
                        }
                        t(e) {
                            const t = b.xmlTextNode(e);
                            return this.node.appendChild(t), this
                        }
                        h(e) {
                            const t = b.xmlGenerator().createElement("body");
                            t.innerHTML = e;
                            const n = b.createHtml(t);
                            for (; n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
                            return this
                        }
                    },
                    Handler: function(e, t, n, s, r, i, o) {
                        this.handler = e, this.ns = t, this.name = n, this.type = s, this.id = r, this.options = o || {
                            matchBareFromJid: !1,
                            ignoreNamespaceFragment: !1
                        }, this.options.matchBare && (b.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = i ? b.getBareJidFromJid(i) : null : this.from = i, this.user = !0
                    }
                };
                b.Handler.prototype = {
                    getNamespace(e) {
                        let t = e.getAttribute("xmlns");
                        return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                    },
                    namespaceMatch(e) {
                        let t = !1;
                        return !this.ns || (b.forEachChild(e, null, (e => {
                            this.getNamespace(e) === this.ns && (t = !0)
                        })), t || this.getNamespace(e) === this.ns)
                    },
                    isMatch(e) {
                        let t = e.getAttribute("from");
                        this.options.matchBareFromJid && (t = b.getBareJidFromJid(t));
                        const n = e.getAttribute("type");
                        return !(!this.namespaceMatch(e) || this.name && !b.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                    },
                    run(e) {
                        let t = null;
                        try {
                            t = this.handler(e)
                        } catch (e) {
                            throw b._handleError(e), e
                        }
                        return t
                    },
                    toString() {
                        return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                    }
                }, b.TimedHandler = class {
                    constructor(e, t) {
                        this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                    }
                    run() {
                        return this.lastCalled = (new Date).getTime(), this.handler()
                    }
                    reset() {
                        this.lastCalled = (new Date).getTime()
                    }
                    toString() {
                        return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                    }
                }, b.Connection = class {
                    constructor(e, t) {
                        this.service = e, this.options = t || {}, this.setProtocol(), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_bind = !1, this.do_session = !1, this.mechanisms = {}, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                            HTTP: {},
                            websocket: {}
                        }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((() => this._onIdle()), 100), a.addCookies(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), this.iqFallbackHandler = new b.Handler((e => this.send(f({
                            type: "error",
                            id: e.getAttribute("id")
                        }).c("error", {
                            type: "cancel"
                        }).c("service-unavailable", {
                            xmlns: b.NS.STANZAS
                        }))), null, "iq", ["get", "set"]);
                        for (const e in b._connectionPlugins)
                            if (Object.prototype.hasOwnProperty.call(b._connectionPlugins, e)) {
                                const t = function() {};
                                t.prototype = b._connectionPlugins[e], this[e] = new t, this[e].init(this)
                            }
                    }
                    setProtocol() {
                        const e = this.options.protocol || "";
                        this.options.worker ? this._proto = new b.WorkerWebsocket(this) : 0 === this.service.indexOf("ws:") || 0 === this.service.indexOf("wss:") || 0 === e.indexOf("ws") ? this._proto = new b.Websocket(this) : this._proto = new b.Bosh(this)
                    }
                    reset() {
                        this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                    }
                    pause() {
                        this.paused = !0
                    }
                    resume() {
                        this.paused = !1
                    }
                    getUniqueId(e) {
                        const t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                            const t = 16 * Math.random() | 0;
                            return ("x" === e ? t : 3 & t | 8).toString(16)
                        }));
                        return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                    }
                    addProtocolErrorHandler(e, t, n) {
                        this.protocolErrorHandlers[e][t] = n
                    }
                    connect(e, t, n, s, r, i, o) {
                        let a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 3e3;
                        this.jid = e, this.authzid = b.getBareJidFromJid(this.jid), this.authcid = o || b.getNodeFromJid(this.jid), this.pass = t, this.scram_keys = null, this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.disconnection_timeout = a, this.domain = b.getDomainFromJid(this.jid), this._changeConnectStatus(b.Status.CONNECTING, null), this._proto._connect(s, r, i)
                    }
                    attach(e, t, n, s, r, i, o) {
                        if (this._proto._attach) return this._proto._attach(e, t, n, s, r, i, o); {
                            const e = new Error('The "attach" method is not available for your connection protocol');
                            throw e.name = "StropheSessionError", e
                        }
                    }
                    restore(e, t, n, s, r) {
                        if (!this._sessionCachingSupported()) {
                            const e = new Error('The "restore" method can only be used with a BOSH connection.');
                            throw e.name = "StropheSessionError", e
                        }
                        this._proto._restore(e, t, n, s, r)
                    }
                    _sessionCachingSupported() {
                        if (this._proto instanceof b.Bosh) {
                            if (!JSON) return !1;
                            try {
                                sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                            } catch (e) {
                                return !1
                            }
                            return !0
                        }
                        return !1
                    }
                    xmlInput(e) {}
                    xmlOutput(e) {}
                    rawInput(e) {}
                    rawOutput(e) {}
                    nextValidRid(e) {}
                    send(e) {
                        if (null !== e) {
                            if ("function" == typeof e.sort)
                                for (let t = 0; t < e.length; t++) this._queueData(e[t]);
                            else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                            this._proto._send()
                        }
                    }
                    flush() {
                        clearTimeout(this._idleTimeout), this._onIdle()
                    }
                    sendPresence(e, t, n, s) {
                        let r = null;
                        "function" == typeof e.tree && (e = e.tree());
                        let i = e.getAttribute("id");
                        if (i || (i = this.getUniqueId("sendPresence"), e.setAttribute("id", i)), "function" == typeof t || "function" == typeof n) {
                            const e = this.addHandler((e => {
                                r && this.deleteTimedHandler(r), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
                            }), null, "presence", null, i);
                            s && (r = this.addTimedHandler(s, (() => (this.deleteHandler(e), n && n(null), !1))))
                        }
                        return this.send(e), i
                    }
                    sendIQ(e, t, n, s) {
                        let r = null;
                        "function" == typeof e.tree && (e = e.tree());
                        let i = e.getAttribute("id");
                        if (i || (i = this.getUniqueId("sendIQ"), e.setAttribute("id", i)), "function" == typeof t || "function" == typeof n) {
                            const e = this.addHandler((e => {
                                r && this.deleteTimedHandler(r);
                                const s = e.getAttribute("type");
                                if ("result" === s) t && t(e);
                                else {
                                    if ("error" !== s) {
                                        const e = new Error(`Got bad IQ type of ${s}`);
                                        throw e.name = "StropheError", e
                                    }
                                    n && n(e)
                                }
                            }), null, "iq", ["error", "result"], i);
                            s && (r = this.addTimedHandler(s, (() => (this.deleteHandler(e), n && n(null), !1))))
                        }
                        return this.send(e), i
                    }
                    _queueData(e) {
                        if (null === e || !e.tagName || !e.childNodes) {
                            const e = new Error("Cannot queue non-DOMElement.");
                            throw e.name = "StropheError", e
                        }
                        this._data.push(e)
                    }
                    _sendRestart() {
                        this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((() => this._onIdle()), 100)
                    }
                    addTimedHandler(e, t) {
                        const n = new b.TimedHandler(e, t);
                        return this.addTimeds.push(n), n
                    }
                    deleteTimedHandler(e) {
                        this.removeTimeds.push(e)
                    }
                    addHandler(e, t, n, s, r, i, o) {
                        const a = new b.Handler(e, t, n, s, r, i, o);
                        return this.addHandlers.push(a), a
                    }
                    deleteHandler(e) {
                        this.removeHandlers.push(e);
                        const t = this.addHandlers.indexOf(e);
                        t >= 0 && this.addHandlers.splice(t, 1)
                    }
                    registerSASLMechanisms(e) {
                        this.mechanisms = {}, (e = e || [b.SASLAnonymous, b.SASLExternal, b.SASLOAuthBearer, b.SASLXOAuth2, b.SASLPlain, b.SASLSHA1, b.SASLSHA256, b.SASLSHA384, b.SASLSHA512]).forEach((e => this.registerSASLMechanism(e)))
                    }
                    registerSASLMechanism(e) {
                        const t = new e;
                        this.mechanisms[t.mechname] = t
                    }
                    disconnect(e) {
                        if (this._changeConnectStatus(b.Status.DISCONNECTING, e), e ? b.warn("Disconnect was called because: " + e) : b.info("Disconnect was called"), this.connected) {
                            let e = !1;
                            this.disconnecting = !0, this.authenticated && (e = _({
                                xmlns: b.NS.CLIENT,
                                type: "unavailable"
                            })), this._disconnectTimeout = this._addSysTimedHandler(this.disconnection_timeout, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(e)
                        } else b.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                    }
                    _changeConnectStatus(e, t, n) {
                        for (const n in b._connectionPlugins)
                            if (Object.prototype.hasOwnProperty.call(b._connectionPlugins, n)) {
                                const s = this[n];
                                if (s.statusChanged) try {
                                    s.statusChanged(e, t)
                                } catch (e) {
                                    b.error(`${n} plugin caused an exception changing status: ${e}`)
                                }
                            }
                        if (this.connect_callback) try {
                            this.connect_callback(e, t, n)
                        } catch (e) {
                            b._handleError(e), b.error(`User connection callback caused an exception: ${e}`)
                        }
                    }
                    _doDisconnect(e) {
                        "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), b.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(b.Status.DISCONNECTED, e), this.connected = !1
                    }
                    _dataRecv(e, t) {
                        const n = this._proto._reqToData(e);
                        if (null === n) return;
                        for (this.xmlInput !== b.Connection.prototype.xmlInput && (n.nodeName === this._proto.strip && n.childNodes.length ? this.xmlInput(n.childNodes[0]) : this.xmlInput(n)), this.rawInput !== b.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(b.serialize(n))); this.removeHandlers.length > 0;) {
                            const e = this.removeHandlers.pop(),
                                t = this.handlers.indexOf(e);
                            t >= 0 && this.handlers.splice(t, 1)
                        }
                        for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                        if (this.disconnecting && this._proto._emptyQueue()) return void this._doDisconnect();
                        const s = n.getAttribute("type");
                        if (null !== s && "terminate" === s) {
                            if (this.disconnecting) return;
                            let e = n.getAttribute("condition");
                            const t = n.getElementsByTagName("conflict");
                            return null !== e ? ("remote-stream-error" === e && t.length > 0 && (e = "conflict"), this._changeConnectStatus(b.Status.CONNFAIL, e)) : this._changeConnectStatus(b.Status.CONNFAIL, b.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(e)
                        }
                        b.forEachChild(n, null, (e => {
                            const t = [];
                            this.handlers = this.handlers.reduce(((n, s) => {
                                try {
                                    !s.isMatch(e) || !this.authenticated && s.user ? n.push(s) : (s.run(e) && n.push(s), t.push(s))
                                } catch (e) {
                                    b.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                }
                                return n
                            }), []), !t.length && this.iqFallbackHandler.isMatch(e) && this.iqFallbackHandler.run(e)
                        }))
                    }
                    _connect_cb(e, t, n) {
                        let s, r;
                        b.debug("_connect_cb was called"), this.connected = !0;
                        try {
                            s = this._proto._reqToData(e)
                        } catch (e) {
                            if (e.name !== b.ErrorCondition.BAD_FORMAT) throw e;
                            this._changeConnectStatus(b.Status.CONNFAIL, b.ErrorCondition.BAD_FORMAT), this._doDisconnect(b.ErrorCondition.BAD_FORMAT)
                        }
                        if (!s) return;
                        if (this.xmlInput !== b.Connection.prototype.xmlInput && (s.nodeName === this._proto.strip && s.childNodes.length ? this.xmlInput(s.childNodes[0]) : this.xmlInput(s)), this.rawInput !== b.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(b.serialize(s))), this._proto._connect_cb(s) === b.Status.CONNFAIL) return;
                        if (r = s.getElementsByTagNameNS ? s.getElementsByTagNameNS(b.NS.STREAM, "features").length > 0 : s.getElementsByTagName("stream:features").length > 0 || s.getElementsByTagName("features").length > 0, !r) return void this._proto._no_auth_received(t);
                        const i = Array.from(s.getElementsByTagName("mechanism")).map((e => this.mechanisms[e.textContent])).filter((e => e));
                        0 !== i.length || 0 !== s.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(i) : this._proto._no_auth_received(t)
                    }
                    sortMechanismsByPriority(e) {
                        for (let t = 0; t < e.length - 1; ++t) {
                            let n = t;
                            for (let s = t + 1; s < e.length; ++s) e[s].priority > e[n].priority && (n = s);
                            if (n !== t) {
                                const s = e[t];
                                e[t] = e[n], e[n] = s
                            }
                        }
                        return e
                    }
                    authenticate(e) {
                        this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                    }
                    _attemptSASLAuth(e) {
                        e = this.sortMechanismsByPriority(e || []);
                        let t = !1;
                        for (let n = 0; n < e.length; ++n) {
                            if (!e[n].test(this)) continue;
                            this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = e[n], this._sasl_mechanism.onStart(this);
                            const s = m("auth", {
                                xmlns: b.NS.SASL,
                                mechanism: this._sasl_mechanism.mechname
                            });
                            if (this._sasl_mechanism.isClientFirst) {
                                const e = this._sasl_mechanism.clientChallenge(this);
                                s.t(p.btoa(e))
                            }
                            this.send(s.tree()), t = !0;
                            break
                        }
                        return t
                    }
                    async _sasl_challenge_cb(e) {
                        const t = p.atob(b.getText(e)),
                            n = await this._sasl_mechanism.onChallenge(this, t),
                            s = m("response", {
                                xmlns: b.NS.SASL
                            });
                        return "" !== n && s.t(p.btoa(n)), this.send(s.tree()), !0
                    }
                    _attemptLegacyAuth() {
                        null === b.getNodeFromJid(this.jid) ? (this._changeConnectStatus(b.Status.CONNFAIL, b.ErrorCondition.MISSING_JID_NODE), this.disconnect(b.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(b.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(f({
                            type: "get",
                            to: this.domain,
                            id: "_auth_1"
                        }).c("query", {
                            xmlns: b.NS.AUTH
                        }).c("username", {}).t(b.getNodeFromJid(this.jid)).tree()))
                    }
                    _onLegacyAuthIQResult(e) {
                        const t = f({
                            type: "set",
                            id: "_auth_2"
                        }).c("query", {
                            xmlns: b.NS.AUTH
                        }).c("username", {}).t(b.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                        return b.getResourceFromJid(this.jid) || (this.jid = b.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(b.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                    }
                    _sasl_success_cb(e) {
                        if (this._sasl_data["server-signature"]) {
                            let t;
                            const n = /([a-z]+)=([^,]+)(,|$)/,
                                s = p.atob(b.getText(e)).match(n);
                            if ("v" === s[1] && (t = s[2]), t !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                        }
                        b.info("SASL authentication succeeded."), this._sasl_data.keys && (this.scram_keys = this._sasl_data.keys), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                        const t = [],
                            n = (e, t) => {
                                for (; e.length;) this.deleteHandler(e.pop());
                                return this._onStreamFeaturesAfterSASL(t), !1
                            };
                        return t.push(this._addSysHandler((e => n(t, e)), null, "stream:features", null, null)), t.push(this._addSysHandler((e => n(t, e)), b.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                    }
                    _onStreamFeaturesAfterSASL(e) {
                        this.features = e;
                        for (let t = 0; t < e.childNodes.length; t++) {
                            const n = e.childNodes[t];
                            "bind" === n.nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0)
                        }
                        return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(b.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(b.Status.AUTHFAIL, null), !1)
                    }
                    bind() {
                        if (!this.do_bind) return void b.log(b.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false');
                        this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
                        const e = b.getResourceFromJid(this.jid);
                        e ? this.send(f({
                            type: "set",
                            id: "_bind_auth_2"
                        }).c("bind", {
                            xmlns: b.NS.BIND
                        }).c("resource", {}).t(e).tree()) : this.send(f({
                            type: "set",
                            id: "_bind_auth_2"
                        }).c("bind", {
                            xmlns: b.NS.BIND
                        }).tree())
                    }
                    _onResourceBindResultIQ(e) {
                        if ("error" === e.getAttribute("type")) {
                            let t;
                            return b.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = b.ErrorCondition.CONFLICT), this._changeConnectStatus(b.Status.AUTHFAIL, t, e), !1
                        }
                        const t = e.getElementsByTagName("bind");
                        if (!(t.length > 0)) return b.warn("Resource binding failed."), this._changeConnectStatus(b.Status.AUTHFAIL, null, e), !1; {
                            const e = t[0].getElementsByTagName("jid");
                            e.length > 0 && (this.authenticated = !0, this.jid = b.getText(e[0]), this.do_session ? this._establishSession() : this._changeConnectStatus(b.Status.CONNECTED, null))
                        }
                    }
                    _establishSession() {
                        if (!this.do_session) throw new Error(`Strophe.Connection.prototype._establishSession called but apparently ${b.NS.SESSION} wasn't advertised by the server`);
                        this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(f({
                            type: "set",
                            id: "_session_auth_2"
                        }).c("session", {
                            xmlns: b.NS.SESSION
                        }).tree())
                    }
                    _onSessionResultIQ(e) {
                        if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(b.Status.CONNECTED, null);
                        else if ("error" === e.getAttribute("type")) return this.authenticated = !1, b.warn("Session creation failed."), this._changeConnectStatus(b.Status.AUTHFAIL, null, e), !1;
                        return !1
                    }
                    _sasl_failure_cb(e) {
                        return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(b.Status.AUTHFAIL, null, e), !1
                    }
                    _auth2_cb(e) {
                        return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(b.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(b.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                    }
                    _addSysTimedHandler(e, t) {
                        const n = new b.TimedHandler(e, t);
                        return n.user = !1, this.addTimeds.push(n), n
                    }
                    _addSysHandler(e, t, n, s, r) {
                        const i = new b.Handler(e, t, n, s, r);
                        return i.user = !1, this.addHandlers.push(i), i
                    }
                    _onDisconnectTimeout() {
                        return b.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(b.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                    }
                    _onIdle() {
                        for (; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                        for (; this.removeTimeds.length > 0;) {
                            const e = this.removeTimeds.pop(),
                                t = this.timedHandlers.indexOf(e);
                            t >= 0 && this.timedHandlers.splice(t, 1)
                        }
                        const e = (new Date).getTime(),
                            t = [];
                        for (let n = 0; n < this.timedHandlers.length; n++) {
                            const s = this.timedHandlers[n];
                            !this.authenticated && s.user || (s.lastCalled + s.period - e <= 0 ? s.run() && t.push(s) : t.push(s))
                        }
                        this.timedHandlers = t, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((() => this._onIdle()), 100))
                    }
                }, b.SASLMechanism = o, b.SASLAnonymous = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "ANONYMOUS", arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 20)
                    }
                    test(e) {
                        return null === e.authcid
                    }
                }, b.SASLPlain = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "PLAIN", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 50)
                    }
                    test(e) {
                        return null !== e.authcid
                    }
                    onChallenge(e) {
                        const {
                            authcid: t,
                            authzid: n,
                            domain: s,
                            pass: r
                        } = e;
                        if (!s) throw new Error("SASLPlain onChallenge: domain is not defined!");
                        let i = n !== `${t}@${s}` ? n : "";
                        return i += "\0", i += t, i += "\0", i += r, a.utf16to8(i)
                    }
                }, b.SASLSHA1 = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "SCRAM-SHA-1", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 60)
                    }
                    test(e) {
                        return null !== e.authcid
                    }
                    async onChallenge(e, t) {
                        return l.scramResponse(e, t, "SHA-1", 160)
                    }
                    clientChallenge(e, t) {
                        return l.clientChallenge(e, t)
                    }
                }, b.SASLSHA256 = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "SCRAM-SHA-256", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 70)
                    }
                    test(e) {
                        return null !== e.authcid
                    }
                    async onChallenge(e, t) {
                        return l.scramResponse(e, t, "SHA-256", 256)
                    }
                    clientChallenge(e, t) {
                        return l.clientChallenge(e, t)
                    }
                }, b.SASLSHA384 = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "SCRAM-SHA-384", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 71)
                    }
                    test(e) {
                        return null !== e.authcid
                    }
                    async onChallenge(e, t) {
                        return l.scramResponse(e, t, "SHA-384", 384)
                    }
                    clientChallenge(e, t) {
                        return l.clientChallenge(e, t)
                    }
                }, b.SASLSHA512 = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "SCRAM-SHA-512", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 72)
                    }
                    test(e) {
                        return null !== e.authcid
                    }
                    async onChallenge(e, t) {
                        return l.scramResponse(e, t, "SHA-512", 512)
                    }
                    clientChallenge(e, t) {
                        return l.clientChallenge(e, t)
                    }
                }, b.SASLOAuthBearer = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "OAUTHBEARER", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 40)
                    }
                    test(e) {
                        return null !== e.pass
                    }
                    onChallenge(e) {
                        let t = "n,";
                        return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", t += "", a.utf16to8(t)
                    }
                }, b.SASLExternal = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "EXTERNAL", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10)
                    }
                    onChallenge(e) {
                        return e.authcid === e.authzid ? "" : e.authzid
                    }
                }, b.SASLXOAuth2 = class extends o {
                    constructor() {
                        super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "X-OAUTH2", !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 30)
                    }
                    test(e) {
                        return null !== e.pass
                    }
                    onChallenge(e) {
                        let t = "\0";
                        return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, a.utf16to8(t)
                    }
                };
                var N = {
                    Strophe: b,
                    $build: m,
                    $iq: f,
                    $msg: g,
                    $pres: _
                };
                b.Request = class {
                    constructor(e, t, n, s) {
                        this.id = ++b._requestId, this.xmlData = e, this.data = b.serialize(e), this.origFunc = t, this.func = t, this.rid = n, this.date = NaN, this.sends = s || 0, this.abort = !1, this.dead = null, this.age = function() {
                            return this.date ? (new Date - this.date) / 1e3 : 0
                        }, this.timeDead = function() {
                            return this.dead ? (new Date - this.dead) / 1e3 : 0
                        }, this.xhr = this._newXHR()
                    }
                    getResponse() {
                        let e = null;
                        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                            if (e = this.xhr.responseXML.documentElement, "parsererror" === e.tagName) throw b.error("invalid response received"), b.error("responseText: " + this.xhr.responseText), b.error("responseXML: " + b.serialize(this.xhr.responseXML)), new Error("parsererror")
                        } else if (this.xhr.responseText) {
                            if (b.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), e = (new r).parseFromString(this.xhr.responseText, "application/xml").documentElement, !e) throw new Error("Parsing produced null node");
                            if (e.querySelector("parsererror")) {
                                b.error("invalid response received: " + e.querySelector("parsererror").textContent), b.error("responseText: " + this.xhr.responseText);
                                const t = new Error;
                                throw t.name = b.ErrorCondition.BAD_FORMAT, t
                            }
                        }
                        return e
                    }
                    _newXHR() {
                        let e = null;
                        return window.XMLHttpRequest ? (e = new XMLHttpRequest, e.overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8")) : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                    }
                }, b.Bosh = class e {
                    constructor(e) {
                        this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                    }
                    _buildBody() {
                        const e = m("body", {
                            rid: this.rid++,
                            xmlns: b.NS.HTTPBIND
                        });
                        return null !== this.sid && e.attrs({
                            sid: this.sid
                        }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
                    }
                    _reset() {
                        this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                    }
                    _connect(e, t, n) {
                        this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
                        const s = this._buildBody().attrs({
                            to: this._conn.domain,
                            "xml:lang": "en",
                            wait: this.wait,
                            hold: this.hold,
                            content: "text/xml; charset=utf-8",
                            ver: "1.6",
                            "xmpp:version": "1.0",
                            "xmlns:xmpp": b.NS.BOSH
                        });
                        n && s.attrs({
                            route: n
                        });
                        const r = this._conn._connect_cb;
                        this._requests.push(new b.Request(s.tree(), this._onRequestStateChange.bind(this, r.bind(this._conn)), s.tree().getAttribute("rid"))), this._throttledRequestHandler()
                    }
                    _attach(e, t, n, s, r, i, o) {
                        this._conn.jid = e, this.sid = t, this.rid = n, this._conn.connect_callback = s, this._conn.domain = b.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = r || this.wait, this.hold = i || this.hold, this.window = o || this.window, this._conn._changeConnectStatus(b.Status.ATTACHED, null)
                    }
                    _restore(e, t, n, s, r) {
                        const i = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                        if (!(null != i && i.rid && i.sid && i.jid && (null == e || b.getBareJidFromJid(i.jid) === b.getBareJidFromJid(e) || null === b.getNodeFromJid(e) && b.getDomainFromJid(i.jid) === e))) {
                            const e = new Error("_restore: no restoreable session.");
                            throw e.name = "StropheSessionError", e
                        }
                        this._conn.restored = !0, this._attach(i.jid, i.sid, i.rid, t, n, s, r)
                    }
                    _cacheSession() {
                        this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                            jid: this._conn.jid,
                            rid: this.rid,
                            sid: this.sid
                        })) : window.sessionStorage.removeItem("strophe-bosh-session")
                    }
                    _connect_cb(e) {
                        const t = e.getAttribute("type");
                        if (null !== t && "terminate" === t) {
                            let t = e.getAttribute("condition");
                            b.error("BOSH-Connection failed: " + t);
                            const n = e.getElementsByTagName("conflict");
                            return null !== t ? ("remote-stream-error" === t && n.length > 0 && (t = "conflict"), this._conn._changeConnectStatus(b.Status.CONNFAIL, t)) : this._conn._changeConnectStatus(b.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(t), b.Status.CONNFAIL
                        }
                        this.sid || (this.sid = e.getAttribute("sid"));
                        const n = e.getAttribute("requests");
                        n && (this.window = parseInt(n, 10));
                        const s = e.getAttribute("hold");
                        s && (this.hold = parseInt(s, 10));
                        const r = e.getAttribute("wait");
                        r && (this.wait = parseInt(r, 10));
                        const i = e.getAttribute("inactivity");
                        i && (this.inactivity = parseInt(i, 10))
                    }
                    _disconnect(e) {
                        this._sendTerminate(e)
                    }
                    _doDisconnect() {
                        this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                    }
                    _emptyQueue() {
                        return 0 === this._requests.length
                    }
                    _callProtocolErrorHandlers(t) {
                        const n = e._getRequestStatus(t),
                            s = this._conn.protocolErrorHandlers.HTTP[n];
                        s && s.call(this, n)
                    }
                    _hitError(e) {
                        this.errors++, b.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                    }
                    _no_auth_received(e) {
                        b.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                        const t = this._buildBody();
                        this._requests.push(new b.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                    }
                    _onDisconnectTimeout() {
                        this._abortAllRequests()
                    }
                    _abortAllRequests() {
                        for (; this._requests.length > 0;) {
                            const e = this._requests.pop();
                            e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                        }
                    }
                    _onIdle() {
                        const e = this._conn._data;
                        if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (b.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
                            if (this._requests.length < 2 && e.length > 0) {
                                const t = this._buildBody();
                                for (let n = 0; n < e.length; n++) null !== e[n] && ("restart" === e[n] ? t.attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    "xmpp:restart": "true",
                                    "xmlns:xmpp": b.NS.BOSH
                                }) : t.cnode(e[n]).up());
                                delete this._conn._data, this._conn._data = [], this._requests.push(new b.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            }
                            if (this._requests.length > 0) {
                                const e = this._requests[0].age();
                                null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(b.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), e > Math.floor(b.TIMEOUT * this.wait) && (b.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(b.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                            }
                        }
                    }
                    static _getRequestStatus(e, t) {
                        let n;
                        if (4 === e.xhr.readyState) try {
                            n = e.xhr.status
                        } catch (e) {
                            b.error("Caught an error while retrieving a request's status, reqStatus: " + n)
                        }
                        return void 0 === n && (n = "number" == typeof t ? t : 0), n
                    }
                    _onRequestStateChange(t, n) {
                        if (b.debug("request id " + n.id + "." + n.sends + " state changed to " + n.xhr.readyState), n.abort) return void(n.abort = !1);
                        if (4 !== n.xhr.readyState) return;
                        const s = e._getRequestStatus(n);
                        if (this.lastResponseHeaders = n.xhr.getAllResponseHeaders(), this._conn.disconnecting && s >= 400) return this._hitError(s), void this._callProtocolErrorHandlers(n);
                        const r = this._requests[0] === n,
                            i = this._requests[1] === n,
                            o = s > 0 && s < 500,
                            a = n.sends > this._conn.maxRetries;
                        (o || a) && (this._removeRequest(n), b.debug("request id " + n.id + " should now be removed")), 200 === s ? ((i || r && this._requests.length > 0 && this._requests[0].age() > Math.floor(b.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(n.rid) + 1), b.debug("request id " + n.id + "." + n.sends + " got 200"), t(n), this.errors = 0) : 0 === s || s >= 400 && s < 600 || s >= 12e3 ? (b.error("request id " + n.id + "." + n.sends + " error " + s + " happened"), this._hitError(s), this._callProtocolErrorHandlers(n), s >= 400 && s < 500 && (this._conn._changeConnectStatus(b.Status.DISCONNECTING, null), this._conn._doDisconnect())) : b.error("request id " + n.id + "." + n.sends + " error " + s + " happened"), o || a ? a && !this._conn.connected && this._conn._changeConnectStatus(b.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                    }
                    _processRequest(t) {
                        let n = this._requests[t];
                        const s = e._getRequestStatus(n, -1);
                        if (n.sends > this._conn.maxRetries) return void this._conn._onDisconnectTimeout();
                        const r = n.age(),
                            i = !isNaN(r) && r > Math.floor(b.TIMEOUT * this.wait),
                            o = null !== n.dead && n.timeDead() > Math.floor(b.SECONDARY_TIMEOUT * this.wait),
                            a = 4 === n.xhr.readyState && (s < 1 || s >= 500);
                        if ((i || o || a) && (o && b.error(`Request ${this._requests[t].id} timed out (secondary), restarting`), n.abort = !0, n.xhr.abort(), n.xhr.onreadystatechange = function() {}, this._requests[t] = new b.Request(n.xmlData, n.origFunc, n.rid, n.sends), n = this._requests[t]), 0 === n.xhr.readyState) {
                            b.debug("request id " + n.id + "." + n.sends + " posting");
                            try {
                                const e = this._conn.options.contentType || "text/xml; charset=utf-8";
                                n.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== n.xhr.setRequestHeader && n.xhr.setRequestHeader("Content-Type", e), this._conn.options.withCredentials && (n.xhr.withCredentials = !0)
                            } catch (e) {
                                return b.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(b.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                            }
                            const e = () => {
                                if (n.date = new Date, this._conn.options.customHeaders) {
                                    const e = this._conn.options.customHeaders;
                                    for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && n.xhr.setRequestHeader(t, e[t])
                                }
                                n.xhr.send(n.data)
                            };
                            if (n.sends > 1) {
                                const t = 1e3 * Math.min(Math.floor(b.TIMEOUT * this.wait), Math.pow(n.sends, 3));
                                setTimeout((function() {
                                    e()
                                }), t)
                            } else e();
                            n.sends++, this._conn.xmlOutput !== b.Connection.prototype.xmlOutput && (n.xmlData.nodeName === this.strip && n.xmlData.childNodes.length ? this._conn.xmlOutput(n.xmlData.childNodes[0]) : this._conn.xmlOutput(n.xmlData)), this._conn.rawOutput !== b.Connection.prototype.rawOutput && this._conn.rawOutput(n.data)
                        } else b.debug("_processRequest: " + (0 === t ? "first" : "second") + " request has readyState of " + n.xhr.readyState)
                    }
                    _removeRequest(e) {
                        b.debug("removing request");
                        for (let t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
                        e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                    }
                    _restartRequest(e) {
                        const t = this._requests[e];
                        null === t.dead && (t.dead = new Date), this._processRequest(e)
                    }
                    _reqToData(e) {
                        try {
                            return e.getResponse()
                        } catch (e) {
                            if ("parsererror" !== e.message) throw e;
                            this._conn.disconnect("strophe-parsererror")
                        }
                    }
                    _sendTerminate(e) {
                        b.debug("_sendTerminate was called");
                        const t = this._buildBody().attrs({
                            type: "terminate"
                        });
                        e && t.cnode(e.tree());
                        const n = new b.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
                        this._requests.push(n), this._throttledRequestHandler()
                    }
                    _send() {
                        clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((() => this._conn._onIdle()), 100)
                    }
                    _sendRestart() {
                        this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                    }
                    _throttledRequestHandler() {
                        this._requests ? b.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : b.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                    }
                }, b.Bosh.prototype.strip = null, b.Websocket = class {
                    constructor(e) {
                        this._conn = e, this.strip = "wrapper";
                        const t = e.service;
                        if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                            let n = "";
                            "ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
                        }
                    }
                    _buildStream() {
                        return m("open", {
                            xmlns: b.NS.FRAMING,
                            to: this._conn.domain,
                            version: "1.0"
                        })
                    }
                    _checkStreamError(e, t) {
                        let n;
                        if (n = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(b.NS.STREAM, "error") : e.getElementsByTagName("stream:error"), 0 === n.length) return !1;
                        const s = n[0];
                        let r = "",
                            i = "";
                        for (let e = 0; e < s.childNodes.length; e++) {
                            const t = s.childNodes[e];
                            if ("urn:ietf:params:xml:ns:xmpp-streams" !== t.getAttribute("xmlns")) break;
                            "text" === t.nodeName ? i = t.textContent : r = t.nodeName
                        }
                        let o = "WebSocket stream error: ";
                        return o += r || "unknown", i && (o += " - " + i), b.error(o), this._conn._changeConnectStatus(t, r), this._conn._doDisconnect(), !0
                    }
                    _reset() {}
                    _connect() {
                        this._closeSocket(), this.socket = new s(this._conn.service, "xmpp"), this.socket.onopen = () => this._onOpen(), this.socket.onerror = e => this._onError(e), this.socket.onclose = e => this._onClose(e), this.socket.onmessage = e => this._onInitialMessage(e)
                    }
                    _connect_cb(e) {
                        if (this._checkStreamError(e, b.Status.CONNFAIL)) return b.Status.CONNFAIL
                    }
                    _handleStreamStart(e) {
                        let t = !1;
                        const n = e.getAttribute("xmlns");
                        "string" != typeof n ? t = "Missing xmlns in <open />" : n !== b.NS.FRAMING && (t = "Wrong xmlns in <open />: " + n);
                        const s = e.getAttribute("version");
                        return "string" != typeof s ? t = "Missing version in <open />" : "1.0" !== s && (t = "Wrong version in <open />: " + s), !t || (this._conn._changeConnectStatus(b.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
                    }
                    _onInitialMessage(e) {
                        if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
                            const t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
                            if ("" === t) return;
                            const n = (new r).parseFromString(t, "text/xml").documentElement;
                            this._conn.xmlInput(n), this._conn.rawInput(e.data), this._handleStreamStart(n) && this._connect_cb(n)
                        } else if (0 === e.data.indexOf("<close ")) {
                            const t = (new r).parseFromString(e.data, "text/xml").documentElement;
                            this._conn.xmlInput(t), this._conn.rawInput(e.data);
                            const n = t.getAttribute("see-other-uri");
                            if (n) {
                                const e = this._conn.service;
                                (e.indexOf("wss:") >= 0 && n.indexOf("wss:") >= 0 || e.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(b.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = n, this._connect())
                            } else this._conn._changeConnectStatus(b.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                        } else {
                            this._replaceMessageHandler();
                            const t = this._streamWrap(e.data),
                                n = (new r).parseFromString(t, "text/xml").documentElement;
                            this._conn._connect_cb(n, null, e.data)
                        }
                    }
                    _replaceMessageHandler() {
                        this.socket.onmessage = e => this._onMessage(e)
                    }
                    _disconnect(e) {
                        if (this.socket && this.socket.readyState !== s.CLOSED) {
                            e && this._conn.send(e);
                            const t = m("close", {
                                xmlns: b.NS.FRAMING
                            });
                            this._conn.xmlOutput(t.tree());
                            const n = b.serialize(t);
                            this._conn.rawOutput(n);
                            try {
                                this.socket.send(n)
                            } catch (e) {
                                b.warn("Couldn't send <close /> tag.")
                            }
                        }
                        setTimeout((() => this._conn._doDisconnect), 0)
                    }
                    _doDisconnect() {
                        b.debug("WebSockets _doDisconnect was called"), this._closeSocket()
                    }
                    _streamWrap(e) {
                        return "<wrapper>" + e + "</wrapper>"
                    }
                    _closeSocket() {
                        if (this.socket) try {
                            this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
                        } catch (e) {
                            b.debug(e.message)
                        }
                        this.socket = null
                    }
                    _emptyQueue() {
                        return !0
                    }
                    _onClose(e) {
                        this._conn.connected && !this._conn.disconnecting ? (b.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (b.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(b.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : b.debug("Websocket closed")
                    }
                    _no_auth_received(e) {
                        b.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(b.Status.CONNFAIL, b.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
                    }
                    _onDisconnectTimeout() {}
                    _abortAllRequests() {}
                    _onError(e) {
                        b.error("Websocket error " + JSON.stringify(e)), this._conn._changeConnectStatus(b.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                    }
                    _onIdle() {
                        const e = this._conn._data;
                        if (e.length > 0 && !this._conn.paused) {
                            for (let t = 0; t < e.length; t++)
                                if (null !== e[t]) {
                                    let n;
                                    n = "restart" === e[t] ? this._buildStream().tree() : e[t];
                                    const s = b.serialize(n);
                                    this._conn.xmlOutput(n), this._conn.rawOutput(s), this.socket.send(s)
                                }
                            this._conn._data = []
                        }
                    }
                    _onMessage(e) {
                        let t;
                        const n = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                        if (e.data === n) return this._conn.rawInput(n), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
                        if (0 === e.data.search("<open ")) {
                            if (t = (new r).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
                        } else {
                            const n = this._streamWrap(e.data);
                            t = (new r).parseFromString(n, "text/xml").documentElement
                        }
                        return this._checkStreamError(t, b.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(b.serialize(t))) : void this._conn._dataRecv(t, e.data)
                    }
                    _onOpen() {
                        b.debug("Websocket open");
                        const e = this._buildStream();
                        this._conn.xmlOutput(e.tree());
                        const t = b.serialize(e);
                        this._conn.rawOutput(t), this.socket.send(t)
                    }
                    _reqToData(e) {
                        return e
                    }
                    _send() {
                        this._conn.flush()
                    }
                    _sendRestart() {
                        clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                    }
                };
                const S = {};
                S.debug = b.LogLevel.DEBUG, S.info = b.LogLevel.INFO, S.warn = b.LogLevel.WARN, S.error = b.LogLevel.ERROR, S.fatal = b.LogLevel.FATAL, b.WorkerWebsocket = class extends b.Websocket {
                    constructor(e) {
                        super(e), this._conn = e, this.worker = new SharedWorker(this._conn.options.worker, "Strophe XMPP Connection"), this.worker.onerror = e => {
                            var t;
                            null === (t = console) || void 0 === t || t.error(e), b.log(b.LogLevel.ERROR, `Shared Worker Error: ${e}`)
                        }
                    }
                    get socket() {
                        return {
                            send: e => this.worker.port.postMessage(["send", e])
                        }
                    }
                    _connect() {
                        this._messageHandler = e => this._onInitialMessage(e), this.worker.port.start(), this.worker.port.onmessage = e => this._onWorkerMessage(e), this.worker.port.postMessage(["_connect", this._conn.service, this._conn.jid])
                    }
                    _attach(e) {
                        this._messageHandler = e => this._onMessage(e), this._conn.connect_callback = e, this.worker.port.start(), this.worker.port.onmessage = e => this._onWorkerMessage(e), this.worker.port.postMessage(["_attach", this._conn.service])
                    }
                    _attachCallback(e, t) {
                        e === b.Status.ATTACHED ? (this._conn.jid = t, this._conn.authenticated = !0, this._conn.connected = !0, this._conn.restored = !0, this._conn._changeConnectStatus(b.Status.ATTACHED)) : e === b.Status.ATTACHFAIL && (this._conn.authenticated = !1, this._conn.connected = !1, this._conn.restored = !1, this._conn._changeConnectStatus(b.Status.ATTACHFAIL))
                    }
                    _disconnect(e, t) {
                        t && this._conn.send(t);
                        const n = m("close", {
                            xmlns: b.NS.FRAMING
                        });
                        this._conn.xmlOutput(n.tree());
                        const s = b.serialize(n);
                        this._conn.rawOutput(s), this.worker.port.postMessage(["send", s]), this._conn._doDisconnect()
                    }
                    _onClose(e) {
                        this._conn.connected && !this._conn.disconnecting ? (b.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected ? (b.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(b.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : b.debug("Websocket closed")
                    }
                    _closeSocket() {
                        this.worker.port.postMessage(["_closeSocket"])
                    }
                    _replaceMessageHandler() {
                        this._messageHandler = e => this._onMessage(e)
                    }
                    _onWorkerMessage(e) {
                        const {
                            data: t
                        } = e, n = t[0];
                        if ("_onMessage" === n) this._messageHandler(t[1]);
                        else if (n in this) try {
                            this[n].apply(this, e.data.slice(1))
                        } catch (e) {
                            b.log(b.LogLevel.ERROR, e)
                        } else if ("log" === n) {
                            const e = t[1],
                                n = t[2];
                            b.log(S[e], n)
                        } else b.log(b.LogLevel.ERROR, `Found unhandled service worker message: ${t}`)
                    }
                }, t.$build = N.$build, t.$iq = N.$iq, t.$msg = N.$msg, t.$pres = N.$pres, t.Strophe = N.Strophe, e.$build = m, e.$iq = f, e.$msg = g, e.$pres = _, e.Strophe = b, Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }(t)
        },
        7026: e => {
            "use strict";
            e.exports = function() {
                throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
            }
        }
    }
]);